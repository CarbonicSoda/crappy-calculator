(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const l of document.querySelectorAll('link[rel="modulepreload"]'))g(l);new MutationObserver(l=>{for(const u of l)if(u.type==="childList")for(const d of u.addedNodes)d.tagName==="LINK"&&d.rel==="modulepreload"&&g(d)}).observe(document,{childList:!0,subtree:!0});function y(l){const u={};return l.integrity&&(u.integrity=l.integrity),l.referrerPolicy&&(u.referrerPolicy=l.referrerPolicy),l.crossOrigin==="use-credentials"?u.credentials="include":l.crossOrigin==="anonymous"?u.credentials="omit":u.credentials="same-origin",u}function g(l){if(l.ep)return;l.ep=!0;const u=y(l);fetch(l.href,u)}})();var r;(t=>{(n=>{n[n.Prefix=0]="Prefix",n[n.Postfix=1]="Postfix",n[n.Function=2]="Function"})(t.UnaryOpTypes||(t.UnaryOpTypes={})),(n=>{n[n.Bracket=0]="Bracket",n[n.Numeral=1]="Numeral",n[n.UnaryOp=2]="UnaryOp",n[n.BinaryOp=3]="BinaryOp"})(t.TokenTypes||(t.TokenTypes={})),(n=>{n[n.Root=0]="Root",n[n.Numeral=1]="Numeral",n[n.UnaryOp=2]="UnaryOp",n[n.BinaryOp=3]="BinaryOp"})(t.TreeTypes||(t.TreeTypes={}))})(r||(r={}));var p;(t=>{t.constantRegistry=new Map,t.constantSymbolRegistry=new Map,t.unaryOpRegistry=new Map,t.unaryOpSymbolRegistry=new Map,t.binaryOpRegistry=new Map,t.binaryOpSymbolRegistry=new Map;function n(o){return t.constantRegistry.has(o)}t.existConstant=n;function y(o){return t.constantSymbolRegistry.has(o)}t.existConstantWithSymbol=y;function g(o){return t.unaryOpRegistry.has(o)}t.existUnaryOp=g;function l(o){return t.unaryOpSymbolRegistry.has(o)}t.existUnaryOpWithSymbol=l;function u(o){return t.binaryOpRegistry.has(o)}t.existBinaryOp=u;function d(o){return t.binaryOpSymbolRegistry.has(o)}t.existBinaryOpWithSymbol=d;function a(o,b){if(n(o))throw new Error(`Constant with id ${o} already exists.`);if(y(b.symbol))throw new Error(`Constant with symbol ${b.symbol} already exists.`);t.constantRegistry.set(o,b),t.constantSymbolRegistry.set(b.symbol,b)}t.registerConstant=a;function T(o,b){if(g(o))throw new Error(`Unary operator with id ${o} already exists.`);if(l(b.symbol))throw new Error(`Unary operator with symbol ${b.symbol} already exists.`);t.unaryOpRegistry.set(o,b),t.unaryOpSymbolRegistry.set(b.symbol,b)}t.registerUnaryOp=T;function w(o,b){if(u(o))throw new Error(`Binary operator with id ${o} already exists.`);if(d(b.symbol))throw new Error(`Binary operator with symbol ${b.symbol} already exists.`);t.binaryOpRegistry.set(o,b),t.binaryOpSymbolRegistry.set(b.symbol,b)}t.registerBinaryOp=w;function E(){return[...t.constantSymbolRegistry.keys()]}t.getConstantSymbols=E;function h(){return[...t.unaryOpSymbolRegistry.keys()]}t.getUnaryOpSymbols=h;function m(){return[...t.binaryOpSymbolRegistry.keys()]}t.getBinaryOpSymbols=m;function O(o){if(!n(o))throw new Error(`Constant with id ${o} is not registered.`);return t.constantRegistry.get(o)}t.getConstant=O;function c(o){if(!y(o))throw new Error(`Constant with symbol ${o} is not registered.`);return t.constantSymbolRegistry.get(o)}t.getConstantWithSymbol=c;function e(o){if(!g(o))throw new Error(`Unary operator with id ${o} is not registered.`);return t.unaryOpRegistry.get(o)}t.getUnaryOp=e;function i(o){if(!l(o))throw new Error(`Unary operator with symbol ${o} is not registered.`);return t.unaryOpSymbolRegistry.get(o)}t.getUnaryOpWithSymbol=i;function s(o){if(!u(o))throw new Error(`Binary operator with id ${o} is not registered.`);return t.binaryOpRegistry.get(o)}t.getBinaryOp=s;function f(o){if(!d(o))throw new Error(`Binary operator with symbol ${o} is not registered.`);return t.binaryOpSymbolRegistry.get(o)}t.getBinaryOpWithSymbol=f})(p||(p={}));var U;(t=>{function y(a){if(a>=0&&a<100&&Number.isInteger(a)){let T=1;for(let w=2;w<a+1;w++)T*=w;return T}return l(a+1)}t.factorial=y;function g(a){return y(a-1)}t.gamma=g;function l(a){const w=[.9999999999998099,676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,15056327351493116e-23];if(a<.5)return Math.PI/(Math.sin(Math.PI*a)*l(1-a));a--;let E=w[0];for(let m=1;m<9;m++)E+=w[m]/(a+m);const h=a+7+.5;return Math.sqrt(2*Math.PI)*Math.pow(h,a+.5)*Math.exp(-h)*E}function u(a,T){return y(a)/y(a-T)}t.permutation=u;function d(a,T){return u(a,T)/y(T)}t.combination=d})(U||(U={}));function P(){p.registerConstant("e",{symbol:"E",value:Math.E}),p.registerConstant("pi",{symbol:"PI",value:Math.PI}),p.registerUnaryOp("pos",{symbol:"+",type:r.UnaryOpTypes.Prefix,callback:n=>n}),p.registerUnaryOp("neg",{symbol:"-",type:r.UnaryOpTypes.Prefix,callback:n=>-n}),p.registerUnaryOp("factorial",{symbol:"!",type:r.UnaryOpTypes.Postfix,callback:U.factorial}),p.registerUnaryOp("abs",{symbol:"abs",type:r.UnaryOpTypes.Function,callback:Math.abs}),p.registerUnaryOp("sqrt",{symbol:"sqrt",type:r.UnaryOpTypes.Function,callback:Math.sqrt}),p.registerUnaryOp("exp",{symbol:"exp",type:r.UnaryOpTypes.Function,callback:Math.exp}),p.registerUnaryOp("log",{symbol:"Ln",type:r.UnaryOpTypes.Function,callback:Math.log}),p.registerUnaryOp("log10",{symbol:"log",type:r.UnaryOpTypes.Function,callback:Math.log10}),p.registerUnaryOp("sin",{symbol:"sin",type:r.UnaryOpTypes.Function,callback:Math.sin}),p.registerUnaryOp("cos",{symbol:"cos",type:r.UnaryOpTypes.Function,callback:Math.cos}),p.registerUnaryOp("tan",{symbol:"tan",type:r.UnaryOpTypes.Function,callback:Math.tan}),p.registerUnaryOp("gamma",{symbol:"Gamma",type:r.UnaryOpTypes.Function,callback:U.gamma}),p.registerBinaryOp("add",{symbol:"+",callback:(n,y)=>n+y,precedence:0}),p.registerBinaryOp("sub",{symbol:"-",callback:(n,y)=>n-y,precedence:0}),p.registerBinaryOp("mul",{symbol:"*",callback:(n,y)=>n*y,precedence:1}),p.registerBinaryOp("div",{symbol:"/",callback:(n,y)=>n/y,precedence:1}),p.registerBinaryOp("pow",{symbol:"^",callback:(n,y)=>n**y,precedence:2}),p.registerBinaryOp("mod",{symbol:"%",callback:(n,y)=>n%y,precedence:2});const t=100;p.registerBinaryOp("min",{symbol:"min",callback:Math.min,precedence:t}),p.registerBinaryOp("max",{symbol:"max",callback:Math.max,precedence:t}),p.registerBinaryOp("permutation",{symbol:"P",callback:U.permutation,precedence:t}),p.registerBinaryOp("combination",{symbol:"C",callback:U.combination,precedence:t})}var B;(t=>{class n{constructor(m,O,c){this.type=m,this.symbol=O,this.meta=c}toString(){return`Token[${this.meta.from}-${this.meta.to}]<${r.TokenTypes[this.type]}> ${this.symbol}`}}t.Token=n;function y(h){const m=h.length,O=[];for(;h.length;){const c=m-h.length,e=d(h,c,O);h=h.slice(e.length)}return O}t.tokenize=y,P();const g=h=>h.replaceAll(/[.*+?^${}()|[\]\\]/g,"\\$&"),l=Object.keys(r.TokenTypes).length/2,u={[r.TokenTypes.Bracket]:/[()]/,[r.TokenTypes.Numeral]:new RegExp(`(?:${p.getConstantSymbols().sort((h,m)=>m.length-h.length).map(g).join(")|(?:")})|(?:\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)`),[r.TokenTypes.UnaryOp]:new RegExp(`(?:${p.getUnaryOpSymbols().sort((h,m)=>m.length-h.length).map(g).join(")|(?:")})`),[r.TokenTypes.BinaryOp]:new RegExp(`(?:${p.getBinaryOpSymbols().sort((h,m)=>m.length-h.length).map(g).join(")|(?:")})`)};function d(h,m,O){let c;for(let e=0;e<l;e++){const i=new RegExp(`^\\s*(?:${u[e].source})\\s*`);if(c=h.match(i)?.[0],c===void 0)continue;let s=c.trimStart();const f=m+c.length-s.length;s=s.trimEnd();const o=f+s.length-1,b={from:f,to:o},x=O.at(-1);switch(e){case r.TokenTypes.Bracket:{if(a(O,s,b,x))break;continue}case r.TokenTypes.Numeral:{if(T(O,s,b,x))break;continue}case r.TokenTypes.UnaryOp:{if(w(O,s,b,x))break;continue}case r.TokenTypes.BinaryOp:{if(E(O,s,b))break;continue}}break}if(!c)throw new SyntaxError(`Unknown symbol at index ${m}.`);return c}function a(h,m,O,c){const e=c?.symbol===")"||c?.type===r.TokenTypes.Numeral||c?.type===r.TokenTypes.UnaryOp&&p.getUnaryOpWithSymbol(c.symbol).type===r.UnaryOpTypes.Postfix;if(m==="("&&e&&p.existBinaryOp("mul")){const s=new n(r.TokenTypes.BinaryOp,p.getBinaryOp("mul").symbol,O);h.push(s)}const i=new n(r.TokenTypes.Bracket,m,O);return h.push(i)}function T(h,m,O,c){const e=c?.symbol===")"||c?.type===r.TokenTypes.Numeral||c?.type===r.TokenTypes.UnaryOp&&p.getUnaryOpWithSymbol(c.symbol).type===r.UnaryOpTypes.Postfix;if(p.existConstantWithSymbol(m)&&e&&p.existBinaryOp("mul")){const s=new n(r.TokenTypes.BinaryOp,p.getBinaryOp("mul").symbol,O);h.push(s)}const i=new n(r.TokenTypes.Numeral,m,O);return h.push(i)}function w(h,m,O,c){const e=c?.symbol===")"||c?.type===r.TokenTypes.Numeral||c?.type===r.TokenTypes.UnaryOp&&p.getUnaryOpWithSymbol(c.symbol).type===r.UnaryOpTypes.Postfix;switch(p.getUnaryOpWithSymbol(m).type){case r.UnaryOpTypes.Prefix:{if(e)return!1;break}case r.UnaryOpTypes.Postfix:{if(!e)return!1;break}case r.UnaryOpTypes.Function:{if(!e||!p.existBinaryOp("mul"))break;const s=new n(r.TokenTypes.BinaryOp,p.getBinaryOp("mul").symbol,O);h.push(s);break}}const i=new n(r.TokenTypes.UnaryOp,m,O);return h.push(i)}function E(h,m,O,c){const e=new n(r.TokenTypes.BinaryOp,m,O);return h.push(e)}})(B||(B={}));var $;(t=>{class n{constructor(e,i){this.type=e,this.precedence=i}clone(){const e=Object.create(Object.getPrototypeOf(this));return Object.defineProperties(e,Object.getOwnPropertyDescriptors(this)),e}}t.Tree=n;const y=-1,g=Number.MAX_SAFE_INTEGER+1,l=Number.MAX_SAFE_INTEGER;class u extends n{$content;set content(e){this.$content=e,e.parent=this}get content(){return this.$content}constructor(){super(r.TreeTypes.Root,y)}toString(){return`${this.content?this.content.toString():"<Empty>"}`}}t.RootTree=u;class d extends n{constructor(e,i){super(r.TreeTypes.Numeral,g),this.parent=e,this.numeral=i}toString(e=1){return`Tree<Numeral>${`
`+"	".repeat(e)}${this.numeral}`}}t.NumeralTree=d;class a extends n{constructor(e,i){super(r.TreeTypes.UnaryOp,l),this.parent=e,this.operatorToken=i,this.operator=p.getUnaryOpWithSymbol(i.symbol),this.meta=i.meta}$argument;set argument(e){this.$argument=e,e.parent=this}get argument(){return this.$argument}operator;meta;toString(e=1){const i=`
`+"	".repeat(e);return`Tree<Unary>${i}Operator: ${this.operatorToken}${i}Argument: ${this.argument?this.argument.toString(e+1):"<Empty>"}`}}t.UnaryOpTree=a;class T extends n{constructor(e,i){const s=p.getBinaryOpWithSymbol(i.symbol);super(r.TreeTypes.BinaryOp,s.precedence),this.parent=e,this.operatorToken=i,this.operator=s,this.meta=i.meta}$left;$right;set left(e){this.$left=e,e.parent=this}get left(){return this.$left}set right(e){this.$right=e,e.parent=this}get right(){return this.$right}operator;meta;toString(e=1){const i=`
`+"	".repeat(e);return`Tree<Binary>${i}Operator: ${this.operatorToken}${i}Left: ${this.left?this.left.toString(e+1):"<Empty>"}${i}Right: ${this.right?this.right.toString(e+1):"<Empty>"}`}}t.BinaryOpTree=T;function w(c){const e=new u,i={index:0,position:()=>{const s=i.tokens[i.index];return`${s.meta.from} - ${s.meta.to}`},tokens:c,pointer:e};for(;i.index<c.length;){const s=c[i.index];switch(s.type){case r.TokenTypes.Bracket:{E(s,i);break}case r.TokenTypes.Numeral:{h(s,i);break}case r.TokenTypes.UnaryOp:{m(s,i);break}case r.TokenTypes.BinaryOp:{O(s,i);break}}i.index++}return e}t.parse=w;function E(c,e){if(c.symbol===")")throw new SyntaxError(`Lone right bracket at ${e.position()}.`);if(e.pointer.type===r.TreeTypes.Numeral)throw new SyntaxError(`Missing operator before bracket at ${e.position()}.`);const i=e.index;let s=i,f=1;for(;s<e.tokens.length-1&&(s++,!(e.tokens[s].type===r.TokenTypes.Bracket&&(e.tokens[s].symbol==="("?f++:f--,f===0))););if(f!==0)throw new SyntaxError(`Unbalanced bracket at ${e.position()}.`);if(s===i+1)throw new SyntaxError(`Empty brackets at ${e.position()}.`);e.index=s;const o=w(e.tokens.slice(i+1,s));switch(o.content.precedence=g,e.pointer.type){case r.TreeTypes.Root:{const b=e.pointer;e.pointer=b.content=o.content;break}case r.TreeTypes.UnaryOp:{const b=e.pointer;e.pointer=b.argument=o.content;break}case r.TreeTypes.BinaryOp:{const b=e.pointer;e.pointer=b.right=o.content;break}}}function h(c,e){if(e.pointer.type===r.TreeTypes.Numeral)throw new SyntaxError(`Missing operator between numerals at ${e.position()}.`);const i=new d(e.pointer,c);switch(e.pointer.type){case r.TreeTypes.Root:{const s=e.pointer;e.pointer=s.content=i;break}case r.TreeTypes.UnaryOp:{const s=e.pointer;e.pointer=s.argument=i;break}case r.TreeTypes.BinaryOp:{const s=e.pointer;e.pointer=s.right=i;break}}}function m(c,e){for(;e.pointer.type!==r.TreeTypes.Root&&e.pointer.precedence>l;)e.pointer=e.pointer.parent;const s=p.getUnaryOpWithSymbol(c.symbol).type===r.UnaryOpTypes.Postfix;if(s&&!(e.pointer.type===r.TreeTypes.Root&&e.pointer.content||e.pointer.type===r.TreeTypes.UnaryOp&&e.pointer.argument||e.pointer.type===r.TreeTypes.BinaryOp&&e.pointer.right))throw new SyntaxError(`Missing entry before postfix unary operator at ${e.position()}.`);const f=new a(e.pointer,c);switch(e.pointer.type){case r.TreeTypes.Root:{const o=e.pointer;s&&(f.argument=o.content.clone()),e.pointer=o.content=f;break}case r.TreeTypes.UnaryOp:{const o=e.pointer;s&&(f.argument=o.argument.clone()),e.pointer=o.argument=f;break}case r.TreeTypes.BinaryOp:{const o=e.pointer;s&&(f.argument=o.right.clone()),e.pointer=o.right=f;break}}}function O(c,e){if(e.pointer.type===r.TreeTypes.Root)throw new SyntaxError(`Missing entry before binary operator at ${e.position()}.`);const i=p.getBinaryOpWithSymbol(c.symbol);for(;e.pointer.precedence>=i.precedence;)e.pointer=e.pointer.parent;const s=new T(e.pointer,c);switch(e.pointer.type){case r.TreeTypes.Root:{const f=e.pointer;s.left=f.content.clone(),e.pointer=f.content=s;break}case r.TreeTypes.UnaryOp:{const f=e.pointer;s.left=f.clone(),e.pointer=f.argument=s;break}case r.TreeTypes.BinaryOp:{const f=e.pointer;s.left=f.right.clone(),e.pointer=f.right=s;break}}}})($||($={}));var C;(t=>{function n(a){switch(a.type){case r.TreeTypes.Root:return g(a);case r.TreeTypes.Numeral:return l(a);case r.TreeTypes.UnaryOp:return u(a);case r.TreeTypes.BinaryOp:return d(a)}}t.evaluate=n;const y=a=>`${a.from} - ${a.to}`;function g(a){if(!a.content)throw new SyntaxError("Evaluating empty tree.");return n(a.content)}function l(a){const T=a.numeral.symbol;return p.existConstantWithSymbol(T)?p.getConstantWithSymbol(T).value:Number(T)}function u(a){if(!a.argument)throw new SyntaxError(`Unary operator lacks argument at ${y(a.meta)}.`);const T=p.getUnaryOpWithSymbol(a.operator.symbol).callback;return T(n(a.argument))}function d(a){if(!a.left)throw new SyntaxError(`Binary operator lacks left operand at ${y(a.meta)}.`);if(!a.right)throw new SyntaxError(`Binary operator lacks right operand at ${y(a.meta)}.`);const T=p.getBinaryOpWithSymbol(a.operator.symbol).callback,w=n(a.left),E=n(a.right);return T(w,E)}})(C||(C={}));var N;(t=>{function n(g){const l=B.tokenize(g),u=$.parse(l),d=C.evaluate(u);return{tokens:l,tree:u,value:d}}t.calculate=n;function y(g){return n(g).value}t.value=y})(N||(N={}));const v=100,S=document.getElementById("input"),k=document.getElementById("result");M(S.getAttribute("placeholder"));S.oninput=()=>M(S.value);function M(t){console.clear(),k.classList.remove("error");let n;try{n=N.calculate(t.length===0?S.getAttribute("placeholder"):t)}catch(y){k.innerHTML="",k.classList.add("error");const g=document.createElement("p");g.textContent=`${y}`.replace(/.*Error: /,""),k.appendChild(g);return}console.log(`${n.tree}`),R(n.tokens,n.value)}function R(t,n){if(k.innerHTML="",t.length>v){const l=document.createElement("p");l.textContent="Expression",k.appendChild(l)}else for(const l of t){const u=document.createElement("p");u.textContent=l.symbol,u.className=r.TokenTypes[l.type],k.appendChild(u)}const y=document.createElement("p");y.textContent=" = ",k.appendChild(y);const g=document.createElement("p");g.textContent=`${n}`,k.appendChild(g)}
