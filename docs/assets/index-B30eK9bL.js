(function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const c of document.querySelectorAll('link[rel="modulepreload"]'))m(c);new MutationObserver(c=>{for(const g of c)if(g.type==="childList")for(const y of g.addedNodes)y.tagName==="LINK"&&y.rel==="modulepreload"&&m(y)}).observe(document,{childList:!0,subtree:!0});function h(c){const g={};return c.integrity&&(g.integrity=c.integrity),c.referrerPolicy&&(g.referrerPolicy=c.referrerPolicy),c.crossOrigin==="use-credentials"?g.credentials="include":c.crossOrigin==="anonymous"?g.credentials="omit":g.credentials="same-origin",g}function m(c){if(c.ep)return;c.ep=!0;const g=h(c);fetch(c.href,g)}})();var n;(t=>{(r=>{r[r.Prefix=0]="Prefix",r[r.Postfix=1]="Postfix",r[r.Function=2]="Function"})(t.UnaryOpTypes||(t.UnaryOpTypes={})),(r=>{r[r.Bracket=0]="Bracket",r[r.Numeral=1]="Numeral",r[r.UnaryOp=2]="UnaryOp",r[r.BinaryOp=3]="BinaryOp"})(t.TokenTypes||(t.TokenTypes={})),(r=>{r[r.Root=0]="Root",r[r.Numeral=1]="Numeral",r[r.UnaryOp=2]="UnaryOp",r[r.BinaryOp=3]="BinaryOp"})(t.TreeTypes||(t.TreeTypes={}))})(n||(n={}));var a;(t=>{t.constantRegistry=new Map,t.constantSymbolRegistry=new Map,t.unaryOpRegistry=new Map,t.unaryOpSymbolRegistry=new Map,t.binaryOpRegistry=new Map,t.binaryOpSymbolRegistry=new Map;function r(o){return t.constantRegistry.has(o)}t.existConstant=r;function h(o){return t.constantSymbolRegistry.has(o)}t.existConstantWithSymbol=h;function m(o){return t.unaryOpRegistry.has(o)}t.existUnaryOp=m;function c(o){return t.unaryOpSymbolRegistry.has(o)}t.existUnaryOpWithSymbol=c;function g(o){return t.binaryOpRegistry.has(o)}t.existBinaryOp=g;function y(o){return t.binaryOpSymbolRegistry.has(o)}t.existBinaryOpWithSymbol=y;function k(o,f){if(r(o))throw new Error(`Constant with id ${o} already exists.`);if(h(f.symbol))throw new Error(`Constant with symbol ${f.symbol} already exists.`);t.constantRegistry.set(o,{id:o,...f}),t.constantSymbolRegistry.set(f.symbol,{id:o,...f})}t.registerConstant=k;function l(o,f){if(m(o))throw new Error(`Unary operator with id ${o} already exists.`);if(c(f.symbol))throw new Error(`Unary operator with symbol ${f.symbol} already exists.`);t.unaryOpRegistry.set(o,{id:o,...f}),t.unaryOpSymbolRegistry.set(f.symbol,{id:o,...f})}t.registerUnaryOp=l;function T(o,f){if(g(o))throw new Error(`Binary operator with id ${o} already exists.`);if(y(f.symbol))throw new Error(`Binary operator with symbol ${f.symbol} already exists.`);t.binaryOpRegistry.set(o,{id:o,...f}),t.binaryOpSymbolRegistry.set(f.symbol,{id:o,...f})}t.registerBinaryOp=T;function w(){return[...t.constantSymbolRegistry.keys()]}t.getConstantSymbols=w;function u(){return[...t.unaryOpSymbolRegistry.keys()]}t.getUnaryOpSymbols=u;function O(){return[...t.binaryOpSymbolRegistry.keys()]}t.getBinaryOpSymbols=O;function b(o){if(!r(o))throw new Error(`Constant with id ${o} is not registered.`);return t.constantRegistry.get(o)}t.getConstant=b;function i(o){if(!h(o))throw new Error(`Constant with symbol ${o} is not registered.`);return t.constantSymbolRegistry.get(o)}t.getConstantWithSymbol=i;function e(o){if(!m(o))throw new Error(`Unary operator with id ${o} is not registered.`);return t.unaryOpRegistry.get(o)}t.getUnaryOp=e;function p(o){if(!c(o))throw new Error(`Unary operator with symbol ${o} is not registered.`);return t.unaryOpSymbolRegistry.get(o)}t.getUnaryOpWithSymbol=p;function s(o){if(!g(o))throw new Error(`Binary operator with id ${o} is not registered.`);return t.binaryOpRegistry.get(o)}t.getBinaryOp=s;function d(o){if(!y(o))throw new Error(`Binary operator with symbol ${o} is not registered.`);return t.binaryOpSymbolRegistry.get(o)}t.getBinaryOpWithSymbol=d})(a||(a={}));var S;(t=>{function h(l){if(l===1/0)return 1/0;if(l>=0&&l<100&&Number.isInteger(l)){let T=1;for(let w=2;w<l+1;w++)T*=w;return T}return c(l+1)}t.factorial=h;function m(l){return h(l-1)}t.gamma=m;function c(l){const w=[.9999999999998099,676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,15056327351493116e-23];if(l<.5)return Math.PI/(Math.sin(Math.PI*l)*c(1-l));l--;let u=w[0];for(let i=1;i<9;i++)u+=w[i]/(l+i);const O=l+7+.5,b=Math.pow(O,l+.5);return b===1/0?1/0:Math.sqrt(2*Math.PI)*b*Math.exp(-O)*u}function g(l,T){return h(l)/h(l-T)}t.permutation=g;function y(l,T){return g(l,T)/h(T)}t.combination=y;function k(l,T){if(!Number.isInteger(l)||!Number.isInteger(T))return NaN;for(;T!==0;)l>T&&([l,T]=[T,l]),T=T%l;return l}t.gcd=k})(S||(S={}));a.registerConstant("e",{symbol:"E",value:Math.E});a.registerConstant("pi",{symbol:"PI",value:Math.PI});a.registerConstant("inf",{symbol:"INF",value:1/0});a.registerUnaryOp("pos",{symbol:"+",type:n.UnaryOpTypes.Prefix,callback:t=>t});a.registerUnaryOp("neg",{symbol:"-",type:n.UnaryOpTypes.Prefix,callback:t=>-t});a.registerUnaryOp("percent",{symbol:"%",type:n.UnaryOpTypes.Postfix,callback:t=>.01*t});a.registerUnaryOp("factorial",{symbol:"!",type:n.UnaryOpTypes.Postfix,callback:S.factorial});a.registerUnaryOp("degree",{symbol:"d",type:n.UnaryOpTypes.Postfix,callback:t=>Math.PI*t/180});a.registerUnaryOp("abs",{symbol:"abs",type:n.UnaryOpTypes.Function,callback:Math.abs});a.registerUnaryOp("floor",{symbol:"floor",type:n.UnaryOpTypes.Function,callback:Math.floor});a.registerUnaryOp("ceil",{symbol:"ceil",type:n.UnaryOpTypes.Function,callback:Math.ceil});a.registerUnaryOp("round",{symbol:"round",type:n.UnaryOpTypes.Function,callback:Math.round});a.registerUnaryOp("sqrt",{symbol:"sqrt",type:n.UnaryOpTypes.Function,callback:Math.sqrt});a.registerUnaryOp("exp",{symbol:"exp",type:n.UnaryOpTypes.Function,callback:Math.exp});a.registerUnaryOp("log",{symbol:"Ln",type:n.UnaryOpTypes.Function,callback:Math.log});a.registerUnaryOp("log10",{symbol:"log",type:n.UnaryOpTypes.Function,callback:Math.log10});a.registerUnaryOp("sin",{symbol:"sin",type:n.UnaryOpTypes.Function,callback:Math.sin});a.registerUnaryOp("cos",{symbol:"cos",type:n.UnaryOpTypes.Function,callback:Math.cos});a.registerUnaryOp("tan",{symbol:"tan",type:n.UnaryOpTypes.Function,callback:Math.tan});a.registerUnaryOp("asin",{symbol:"asin",type:n.UnaryOpTypes.Function,callback:Math.asin});a.registerUnaryOp("acos",{symbol:"acos",type:n.UnaryOpTypes.Function,callback:Math.acos});a.registerUnaryOp("atan",{symbol:"atan",type:n.UnaryOpTypes.Function,callback:Math.atan});a.registerUnaryOp("gamma",{symbol:"Gamma",type:n.UnaryOpTypes.Function,callback:S.gamma});a.registerBinaryOp("add",{symbol:"+",callback:(t,r)=>t+r,precedence:0});a.registerBinaryOp("sub",{symbol:"-",callback:(t,r)=>t-r,precedence:0});a.registerBinaryOp("mul",{symbol:"*",callback:(t,r)=>t*r,precedence:1});a.registerBinaryOp("div",{symbol:"/",callback:(t,r)=>t/r,precedence:1});a.registerBinaryOp("int_div",{symbol:"//",callback:(t,r)=>Math.floor(t/r),precedence:1});a.registerBinaryOp("pow",{symbol:"**",callback:(t,r)=>t**r,precedence:2});a.registerBinaryOp("pow_alias",{symbol:"^",callback:(t,r)=>t**r,precedence:2});a.registerBinaryOp("mod",{symbol:"mod",callback:(t,r)=>t%r,precedence:2});const E=100;a.registerBinaryOp("min",{symbol:"min",callback:Math.min,precedence:E});a.registerBinaryOp("max",{symbol:"max",callback:Math.max,precedence:E});a.registerBinaryOp("permutation",{symbol:"P",callback:S.permutation,precedence:E});a.registerBinaryOp("combination",{symbol:"C",callback:S.combination,precedence:E});a.registerBinaryOp("gcd",{symbol:"gcd",callback:S.gcd,precedence:E});var N;(t=>{function r(u){const O=u.length,b=[];for(;u.length;){const i=O-u.length,e=y(u,i,b);u=u.slice(e.length)}return b}t.tokenize=r;class h{constructor(O,b,i){this.type=O,this.symbol=b,this.meta=i}get position(){return this.meta.from===this.meta.to?`${this.meta.from}`:`${this.meta.from}-${this.meta.to}`}toString(){return`[${this.position}] ${this.symbol}`}toJSON(){return{symbol:this.symbol,meta:this.meta}}}t.Token=h;const m=u=>u.replaceAll(/[.*+?^${}()|[\]\\]/g,"\\$&"),c=Object.keys(n.TokenTypes).length/2,g={[n.TokenTypes.Bracket]:/[()]/,[n.TokenTypes.Numeral]:new RegExp(`(?:${a.getConstantSymbols().sort((u,O)=>O.length-u.length).map(m).join(")|(?:")})|(?:\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)`),[n.TokenTypes.UnaryOp]:new RegExp(`(?:${a.getUnaryOpSymbols().sort((u,O)=>O.length-u.length).map(m).join(")|(?:")})`),[n.TokenTypes.BinaryOp]:new RegExp(`(?:${a.getBinaryOpSymbols().sort((u,O)=>O.length-u.length).map(m).join(")|(?:")})`)};function y(u,O,b){let i;for(let e=0;e<c;e++){const p=new RegExp(`^\\s*(?:${g[e].source})\\s*`);if(i=u.match(p)?.[0],i===void 0)continue;let s=i.trimStart();const d=O+i.length-s.length;s=s.trimEnd();const o=d+s.length-1,f={from:d,to:o},x=b.at(-1);switch(e){case n.TokenTypes.Bracket:{if(k(b,s,x,f))break;continue}case n.TokenTypes.Numeral:{if(l(b,s,x,f))break;continue}case n.TokenTypes.UnaryOp:{if(T(b,s,x,f))break;continue}case n.TokenTypes.BinaryOp:{if(w(b,s,x,f))break;continue}}break}if(!i)throw new SyntaxError(`Invalid symbol at ${O}.`);return i}function k(u,O,b,i){const e=b?.symbol===")"||b?.type===n.TokenTypes.Numeral||b?.type===n.TokenTypes.UnaryOp&&a.getUnaryOpWithSymbol(b.symbol).type===n.UnaryOpTypes.Postfix;if(O==="("&&e&&a.existBinaryOp("mul")){const s=new h(n.TokenTypes.BinaryOp,a.getBinaryOp("mul").symbol,i);u.push(s)}const p=new h(n.TokenTypes.Bracket,O,i);return u.push(p)}function l(u,O,b,i){if(b?.symbol===")"||b?.type===n.TokenTypes.Numeral||b?.type===n.TokenTypes.UnaryOp&&a.getUnaryOpWithSymbol(b.symbol).type===n.UnaryOpTypes.Postfix)if(a.existConstantWithSymbol(O)&&a.existBinaryOp("mul")){const s=new h(n.TokenTypes.BinaryOp,a.getBinaryOp("mul").symbol,i);u.push(s)}else return!1;const p=new h(n.TokenTypes.Numeral,O,i);return u.push(p)}function T(u,O,b,i){const e=b?.symbol===")"||b?.type===n.TokenTypes.Numeral||b?.type===n.TokenTypes.UnaryOp&&a.getUnaryOpWithSymbol(b.symbol).type===n.UnaryOpTypes.Postfix;switch(a.getUnaryOpWithSymbol(O).type){case n.UnaryOpTypes.Prefix:{if(e)return!1;break}case n.UnaryOpTypes.Postfix:{if(!e)return!1;break}case n.UnaryOpTypes.Function:{if(!e||!a.existBinaryOp("mul"))break;const s=new h(n.TokenTypes.BinaryOp,a.getBinaryOp("mul").symbol,i);u.push(s);break}}const p=new h(n.TokenTypes.UnaryOp,O,i);return u.push(p)}function w(u,O,b,i){const e=new h(n.TokenTypes.BinaryOp,O,i);return u.push(e)}})(N||(N={}));var $;(t=>{function r(i){const e=new y,p={index:0,tokens:i,pointer:e,position:()=>p.tokens[p.index].position};for(;p.index<i.length;){const s=i[p.index];switch(s.type){case n.TokenTypes.Bracket:{w(s,p);break}case n.TokenTypes.Numeral:{u(s,p);break}case n.TokenTypes.UnaryOp:{O(s,p);break}case n.TokenTypes.BinaryOp:{b(s,p);break}}p.index++}return e}t.parse=r;class h{constructor(e,p){this.type=e,this.precedence=p}clone(){const e=Object.create(Object.getPrototypeOf(this));return Object.defineProperties(e,Object.getOwnPropertyDescriptors(this)),e}}t.Tree=h;const m=-1,c=Number.MAX_SAFE_INTEGER+1,g=Number.MAX_SAFE_INTEGER;class y extends h{$content;set content(e){this.$content=e,e.parent=this}get content(){return this.$content}constructor(){super(n.TreeTypes.Root,m)}toString(){return this.content?this.content.toString():"<Empty>"}toJSON(){return this.content?.toJSON()??{}}}t.RootTree=y;class k extends h{constructor(e,p){super(n.TreeTypes.Numeral,c),this.parent=e,this.numToken=p}toString(){return`<Num> ${this.numToken}`}toJSON(){return{numeral:this.numToken.toJSON()}}}t.NumeralTree=k;class l extends h{constructor(e,p){super(n.TreeTypes.UnaryOp,g),this.parent=e,this.opToken=p,this.operator=a.getUnaryOpWithSymbol(p.symbol)}$argument;set argument(e){this.$argument=e,e.parent=this}get argument(){return this.$argument}operator;toString(e=1){const p=`
`+"  ┃  ".repeat(e);return`<Unary>${p}UOp: ${this.opToken} (${this.operator.id})${p}Arg: ${this.argument?this.argument.toString(e+1):"<Empty>"}`}toJSON(){return{operator:{...this.opToken.toJSON(),...this.operator,type:n.UnaryOpTypes[this.operator.type]},argument:this.argument?.toJSON()??{}}}}t.UnaryOpTree=l;class T extends h{constructor(e,p){const s=a.getBinaryOpWithSymbol(p.symbol);super(n.TreeTypes.BinaryOp,s.precedence),this.parent=e,this.opToken=p,this.operator=s}$left;$right;set left(e){this.$left=e,e.parent=this}get left(){return this.$left}set right(e){this.$right=e,e.parent=this}get right(){return this.$right}operator;toString(e=1){const p=`
`+"  ┃  ".repeat(e);return`<Binary>${p}BOp: ${this.opToken} (${this.operator.id})${p}Lft: ${this.left?this.left.toString(e+1):"<Empty>"}${p}Rgt: ${this.right?this.right.toString(e+1):"<Empty>"}`}toJSON(){return{operator:{...this.opToken.toJSON(),...this.operator},left:this.left?.toJSON()??{},right:this.right?.toJSON()??{}}}}t.BinaryOpTree=T;function w(i,e){if(i.symbol===")")throw new SyntaxError(`Lone right bracket at ${e.position()}.`);if(e.pointer.type===n.TreeTypes.Numeral)throw new SyntaxError(`Missing operator before bracket at ${e.position()}.`);const p=e.index;let s=p,d=1;for(;s<e.tokens.length-1&&(s++,!(e.tokens[s].type===n.TokenTypes.Bracket&&(e.tokens[s].symbol==="("?d++:d--,d===0))););if(d!==0)throw new SyntaxError(`Unbalanced bracket at ${e.position()}.`);if(s===p+1)throw new SyntaxError(`Empty brackets at ${e.position()}.`);e.index=s;const o=r(e.tokens.slice(p+1,s));switch(o.content.precedence=c,e.pointer.type){case n.TreeTypes.Root:{const f=e.pointer;e.pointer=f.content=o.content;break}case n.TreeTypes.UnaryOp:{const f=e.pointer;e.pointer=f.argument=o.content;break}case n.TreeTypes.BinaryOp:{const f=e.pointer;e.pointer=f.right=o.content;break}}}function u(i,e){if(e.pointer.type===n.TreeTypes.Numeral)throw new SyntaxError(`Missing operator between numerals at ${e.position()}.`);const p=new k(e.pointer,i);switch(e.pointer.type){case n.TreeTypes.Root:{const s=e.pointer;e.pointer=s.content=p;break}case n.TreeTypes.UnaryOp:{const s=e.pointer;e.pointer=s.argument=p;break}case n.TreeTypes.BinaryOp:{const s=e.pointer;e.pointer=s.right=p;break}}}function O(i,e){for(;e.pointer.type!==n.TreeTypes.Root&&e.pointer.precedence>g;)e.pointer=e.pointer.parent;const s=a.getUnaryOpWithSymbol(i.symbol).type===n.UnaryOpTypes.Postfix;if(s&&!(e.pointer.type===n.TreeTypes.Root&&e.pointer.content||e.pointer.type===n.TreeTypes.UnaryOp&&e.pointer.argument||e.pointer.type===n.TreeTypes.BinaryOp&&e.pointer.right))throw new SyntaxError(`Missing entry before postfix unary operator at ${e.position()}.`);const d=new l(e.pointer,i);switch(e.pointer.type){case n.TreeTypes.Root:{const o=e.pointer;s&&(d.argument=o.content.clone()),e.pointer=o.content=d;break}case n.TreeTypes.UnaryOp:{const o=e.pointer;s&&(d.argument=o.argument.clone()),e.pointer=o.argument=d;break}case n.TreeTypes.BinaryOp:{const o=e.pointer;s&&(d.argument=o.right.clone()),e.pointer=o.right=d;break}}}function b(i,e){if(e.pointer.type===n.TreeTypes.Root)throw new SyntaxError(`Missing entry before binary operator at ${e.position()}.`);const p=a.getBinaryOpWithSymbol(i.symbol);for(;e.pointer.precedence>=p.precedence;)e.pointer=e.pointer.parent;const s=new T(e.pointer,i);switch(e.pointer.type){case n.TreeTypes.Root:{const d=e.pointer;s.left=d.content.clone(),e.pointer=d.content=s;break}case n.TreeTypes.UnaryOp:{const d=e.pointer;s.left=d.clone(),e.pointer=d.argument=s;break}case n.TreeTypes.BinaryOp:{const d=e.pointer;s.left=d.right.clone(),e.pointer=d.right=s;break}}}})($||($={}));var M;(t=>{function r(y){switch(y.type){case n.TreeTypes.Root:return h(y);case n.TreeTypes.Numeral:return m(y);case n.TreeTypes.UnaryOp:return c(y);case n.TreeTypes.BinaryOp:return g(y)}}t.evaluate=r;function h(y){if(!y.content)throw new SyntaxError("Evaluating empty tree.");return r(y.content)}function m(y){const k=y.numToken.symbol;return a.existConstantWithSymbol(k)?a.getConstantWithSymbol(k).value:Number(k)}function c(y){if(!y.argument)throw new SyntaxError(`Unary operator lacks argument at ${y.opToken.position}.`);const k=a.getUnaryOpWithSymbol(y.operator.symbol).callback;return k(r(y.argument))}function g(y){if(!y.left)throw new SyntaxError(`Binary operator lacks left operand at ${y.opToken.position}.`);if(!y.right)throw new SyntaxError(`Binary operator lacks right operand at ${y.opToken.position}.`);const k=a.getBinaryOpWithSymbol(y.operator.symbol).callback,l=r(y.left),T=r(y.right);return k(l,T)}})(M||(M={}));var C;(t=>{function r(m){const c=N.tokenize(m),g=$.parse(c),y=M.evaluate(g);return{tokens:c,tree:g,value:y}}t.calculate=r;function h(m){return r(m).value}t.value=h})(C||(C={}));const v=50,B=document.getElementById("input"),U=document.getElementById("result");P(B.getAttribute("placeholder"));B.oninput=()=>P(B.value);function P(t){console.clear(),U.classList.remove("error");let r,h;try{const m=performance.now();r=C.calculate(t.length===0?B.getAttribute("placeholder"):t),h=performance.now()-m}catch(m){U.innerHTML="",U.classList.add("error");const c=document.createElement("p");c.textContent=`${m}`.replace(/.*Error: /,""),U.appendChild(c);return}console.log(`Calculated in ${h}ms.`),console.log("<AST>",r.tree.toJSON()),console.log(`${r.tree}`),I(r.tokens,r.value)}function I(t,r){if(U.innerHTML="",t.reduce((m,c)=>m+c.symbol.length,0)>v){const m=document.createElement("p");m.textContent="Expression",U.appendChild(m)}else for(const m of t){const c=document.createElement("p");c.textContent=m.symbol,c.className=n.TokenTypes[m.type],U.appendChild(c)}const h=document.createElement("p");h.textContent=` = ${r}`,U.appendChild(h)}
