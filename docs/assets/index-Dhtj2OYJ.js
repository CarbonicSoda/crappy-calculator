(function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const c of document.querySelectorAll('link[rel="modulepreload"]'))f(c);new MutationObserver(c=>{for(const b of c)if(b.type==="childList")for(const y of b.addedNodes)y.tagName==="LINK"&&y.rel==="modulepreload"&&f(y)}).observe(document,{childList:!0,subtree:!0});function l(c){const b={};return c.integrity&&(b.integrity=c.integrity),c.referrerPolicy&&(b.referrerPolicy=c.referrerPolicy),c.crossOrigin==="use-credentials"?b.credentials="include":c.crossOrigin==="anonymous"?b.credentials="omit":b.credentials="same-origin",b}function f(c){if(c.ep)return;c.ep=!0;const b=l(c);fetch(c.href,b)}})();var n;(t=>{(r=>{r[r.Prefix=0]="Prefix",r[r.Postfix=1]="Postfix",r[r.Function=2]="Function"})(t.UnaryOpTypes||(t.UnaryOpTypes={})),(r=>{r[r.Bracket=0]="Bracket",r[r.Numeral=1]="Numeral",r[r.UnaryOp=2]="UnaryOp",r[r.BinaryOp=3]="BinaryOp"})(t.TokenTypes||(t.TokenTypes={})),(r=>{r[r.Root=0]="Root",r[r.Numeral=1]="Numeral",r[r.UnaryOp=2]="UnaryOp",r[r.BinaryOp=3]="BinaryOp"})(t.TreeTypes||(t.TreeTypes={}))})(n||(n={}));var a;(t=>{t.constantRegistry=new Map,t.constantSymbolRegistry=new Map,t.unaryOpRegistry=new Map,t.unaryOpSymbolRegistry=new Map,t.binaryOpRegistry=new Map,t.binaryOpSymbolRegistry=new Map;function r(o){return t.constantRegistry.has(o)}t.existConstant=r;function l(o){return t.constantSymbolRegistry.has(o)}t.existConstantWithSymbol=l;function f(o){return t.unaryOpRegistry.has(o)}t.existUnaryOp=f;function c(o){return t.unaryOpSymbolRegistry.has(o)}t.existUnaryOpWithSymbol=c;function b(o){return t.binaryOpRegistry.has(o)}t.existBinaryOp=b;function y(o){return t.binaryOpSymbolRegistry.has(o)}t.existBinaryOpWithSymbol=y;function h(o,g){if(r(o))throw new Error(`Constant with id ${o} already exists.`);if(l(g.symbol))throw new Error(`Constant with symbol ${g.symbol} already exists.`);t.constantRegistry.set(o,{id:o,...g}),t.constantSymbolRegistry.set(g.symbol,{id:o,...g})}t.registerConstant=h;function d(o,g){if(f(o))throw new Error(`Unary operator with id ${o} already exists.`);if(c(g.symbol))throw new Error(`Unary operator with symbol ${g.symbol} already exists.`);t.unaryOpRegistry.set(o,{id:o,...g}),t.unaryOpSymbolRegistry.set(g.symbol,{id:o,...g})}t.registerUnaryOp=d;function k(o,g){if(b(o))throw new Error(`Binary operator with id ${o} already exists.`);if(y(g.symbol))throw new Error(`Binary operator with symbol ${g.symbol} already exists.`);t.binaryOpRegistry.set(o,{id:o,...g}),t.binaryOpSymbolRegistry.set(g.symbol,{id:o,...g})}t.registerBinaryOp=k;function U(){return[...t.constantSymbolRegistry.keys()]}t.getConstantSymbols=U;function u(){return[...t.unaryOpSymbolRegistry.keys()]}t.getUnaryOpSymbols=u;function m(){return[...t.binaryOpSymbolRegistry.keys()]}t.getBinaryOpSymbols=m;function O(o){if(!r(o))throw new Error(`Constant with id ${o} is not registered.`);return t.constantRegistry.get(o)}t.getConstant=O;function i(o){if(!l(o))throw new Error(`Constant with symbol ${o} is not registered.`);return t.constantSymbolRegistry.get(o)}t.getConstantWithSymbol=i;function e(o){if(!f(o))throw new Error(`Unary operator with id ${o} is not registered.`);return t.unaryOpRegistry.get(o)}t.getUnaryOp=e;function p(o){if(!c(o))throw new Error(`Unary operator with symbol ${o} is not registered.`);return t.unaryOpSymbolRegistry.get(o)}t.getUnaryOpWithSymbol=p;function s(o){if(!b(o))throw new Error(`Binary operator with id ${o} is not registered.`);return t.binaryOpRegistry.get(o)}t.getBinaryOp=s;function T(o){if(!y(o))throw new Error(`Binary operator with symbol ${o} is not registered.`);return t.binaryOpSymbolRegistry.get(o)}t.getBinaryOpWithSymbol=T})(a||(a={}));var S;(t=>{function l(h){if(h===1/0)return 1/0;if(h>=0&&h<100&&Number.isInteger(h)){let d=1;for(let k=2;k<h+1;k++)d*=k;return d}return c(h+1)}t.factorial=l;function f(h){return l(h-1)}t.gamma=f;function c(h){const k=[.9999999999998099,676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,15056327351493116e-23];if(h<.5)return Math.PI/(Math.sin(Math.PI*h)*c(1-h));h--;let U=k[0];for(let O=1;O<9;O++)U+=k[O]/(h+O);const u=h+7+.5,m=Math.pow(u,h+.5);return m===1/0?1/0:Math.sqrt(2*Math.PI)*m*Math.exp(-u)*U}function b(h,d){return l(h)/l(h-d)}t.permutation=b;function y(h,d){return b(h,d)/l(d)}t.combination=y})(S||(S={}));a.registerConstant("e",{symbol:"E",value:Math.E});a.registerConstant("pi",{symbol:"PI",value:Math.PI});a.registerUnaryOp("pos",{symbol:"+",type:n.UnaryOpTypes.Prefix,callback:t=>t});a.registerUnaryOp("neg",{symbol:"-",type:n.UnaryOpTypes.Prefix,callback:t=>-t});a.registerUnaryOp("factorial",{symbol:"!",type:n.UnaryOpTypes.Postfix,callback:S.factorial});a.registerUnaryOp("degree",{symbol:"d",type:n.UnaryOpTypes.Postfix,callback:t=>Math.PI*t/180});a.registerUnaryOp("abs",{symbol:"abs",type:n.UnaryOpTypes.Function,callback:Math.abs});a.registerUnaryOp("floor",{symbol:"floor",type:n.UnaryOpTypes.Function,callback:Math.floor});a.registerUnaryOp("ceil",{symbol:"ceil",type:n.UnaryOpTypes.Function,callback:Math.ceil});a.registerUnaryOp("round",{symbol:"round",type:n.UnaryOpTypes.Function,callback:Math.round});a.registerUnaryOp("sqrt",{symbol:"sqrt",type:n.UnaryOpTypes.Function,callback:Math.sqrt});a.registerUnaryOp("exp",{symbol:"exp",type:n.UnaryOpTypes.Function,callback:Math.exp});a.registerUnaryOp("log",{symbol:"Ln",type:n.UnaryOpTypes.Function,callback:Math.log});a.registerUnaryOp("log10",{symbol:"log",type:n.UnaryOpTypes.Function,callback:Math.log10});a.registerUnaryOp("sin",{symbol:"sin",type:n.UnaryOpTypes.Function,callback:Math.sin});a.registerUnaryOp("cos",{symbol:"cos",type:n.UnaryOpTypes.Function,callback:Math.cos});a.registerUnaryOp("tan",{symbol:"tan",type:n.UnaryOpTypes.Function,callback:Math.tan});a.registerUnaryOp("asin",{symbol:"asin",type:n.UnaryOpTypes.Function,callback:Math.asin});a.registerUnaryOp("acos",{symbol:"acos",type:n.UnaryOpTypes.Function,callback:Math.acos});a.registerUnaryOp("atan",{symbol:"atan",type:n.UnaryOpTypes.Function,callback:Math.atan});a.registerUnaryOp("gamma",{symbol:"Gamma",type:n.UnaryOpTypes.Function,callback:S.gamma});a.registerBinaryOp("add",{symbol:"+",callback:(t,r)=>t+r,precedence:0});a.registerBinaryOp("sub",{symbol:"-",callback:(t,r)=>t-r,precedence:0});a.registerBinaryOp("mul",{symbol:"*",callback:(t,r)=>t*r,precedence:1});a.registerBinaryOp("div",{symbol:"/",callback:(t,r)=>t/r,precedence:1});a.registerBinaryOp("int_div",{symbol:"//",callback:(t,r)=>Math.floor(t/r),precedence:1});a.registerBinaryOp("pow",{symbol:"**",callback:(t,r)=>t**r,precedence:2});a.registerBinaryOp("pow_alias",{symbol:"^",callback:(t,r)=>t**r,precedence:2});a.registerBinaryOp("mod",{symbol:"%",callback:(t,r)=>t%r,precedence:2});const B=100;a.registerBinaryOp("min",{symbol:"min",callback:Math.min,precedence:B});a.registerBinaryOp("max",{symbol:"max",callback:Math.max,precedence:B});a.registerBinaryOp("permutation",{symbol:"P",callback:S.permutation,precedence:B});a.registerBinaryOp("combination",{symbol:"C",callback:S.combination,precedence:B});var $;(t=>{function r(u){const m=u.length,O=[];for(;u.length;){const i=m-u.length,e=y(u,i,O);u=u.slice(e.length)}return O}t.tokenize=r;class l{constructor(m,O,i){this.type=m,this.symbol=O,this.meta=i}get position(){return this.meta.from===this.meta.to?`${this.meta.from}`:`${this.meta.from}-${this.meta.to}`}toString(){return`[${this.position}] ${this.symbol}`}toJSON(){return{symbol:this.symbol,meta:this.meta}}}t.Token=l;const f=u=>u.replaceAll(/[.*+?^${}()|[\]\\]/g,"\\$&"),c=Object.keys(n.TokenTypes).length/2,b={[n.TokenTypes.Bracket]:/[()]/,[n.TokenTypes.Numeral]:new RegExp(`(?:${a.getConstantSymbols().sort((u,m)=>m.length-u.length).map(f).join(")|(?:")})|(?:\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)`),[n.TokenTypes.UnaryOp]:new RegExp(`(?:${a.getUnaryOpSymbols().sort((u,m)=>m.length-u.length).map(f).join(")|(?:")})`),[n.TokenTypes.BinaryOp]:new RegExp(`(?:${a.getBinaryOpSymbols().sort((u,m)=>m.length-u.length).map(f).join(")|(?:")})`)};function y(u,m,O){let i;for(let e=0;e<c;e++){const p=new RegExp(`^\\s*(?:${b[e].source})\\s*`);if(i=u.match(p)?.[0],i===void 0)continue;let s=i.trimStart();const T=m+i.length-s.length;s=s.trimEnd();const o=T+s.length-1,g={from:T,to:o},x=O.at(-1);switch(e){case n.TokenTypes.Bracket:{if(h(O,s,g,x))break;continue}case n.TokenTypes.Numeral:{if(d(O,s,g,x))break;continue}case n.TokenTypes.UnaryOp:{if(k(O,s,g,x))break;continue}case n.TokenTypes.BinaryOp:{if(U(O,s,g))break;continue}}break}if(!i)throw new SyntaxError(`Invalid symbol at ${m}.`);return i}function h(u,m,O,i){const e=i?.symbol===")"||i?.type===n.TokenTypes.Numeral||i?.type===n.TokenTypes.UnaryOp&&a.getUnaryOpWithSymbol(i.symbol).type===n.UnaryOpTypes.Postfix;if(m==="("&&e&&a.existBinaryOp("mul")){const s=new l(n.TokenTypes.BinaryOp,a.getBinaryOp("mul").symbol,O);u.push(s)}const p=new l(n.TokenTypes.Bracket,m,O);return u.push(p)}function d(u,m,O,i){const e=i?.symbol===")"||i?.type===n.TokenTypes.Numeral||i?.type===n.TokenTypes.UnaryOp&&a.getUnaryOpWithSymbol(i.symbol).type===n.UnaryOpTypes.Postfix;if(a.existConstantWithSymbol(m)&&e&&a.existBinaryOp("mul")){const s=new l(n.TokenTypes.BinaryOp,a.getBinaryOp("mul").symbol,O);u.push(s)}const p=new l(n.TokenTypes.Numeral,m,O);return u.push(p)}function k(u,m,O,i){const e=i?.symbol===")"||i?.type===n.TokenTypes.Numeral||i?.type===n.TokenTypes.UnaryOp&&a.getUnaryOpWithSymbol(i.symbol).type===n.UnaryOpTypes.Postfix;switch(a.getUnaryOpWithSymbol(m).type){case n.UnaryOpTypes.Prefix:{if(e)return!1;break}case n.UnaryOpTypes.Postfix:{if(!e)return!1;break}case n.UnaryOpTypes.Function:{if(!e||!a.existBinaryOp("mul"))break;const s=new l(n.TokenTypes.BinaryOp,a.getBinaryOp("mul").symbol,O);u.push(s);break}}const p=new l(n.TokenTypes.UnaryOp,m,O);return u.push(p)}function U(u,m,O,i){const e=new l(n.TokenTypes.BinaryOp,m,O);return u.push(e)}})($||($={}));var N;(t=>{function r(i){const e=new y,p={index:0,position:()=>p.tokens[p.index].position,tokens:i,pointer:e};for(;p.index<i.length;){const s=i[p.index];switch(s.type){case n.TokenTypes.Bracket:{U(s,p);break}case n.TokenTypes.Numeral:{u(s,p);break}case n.TokenTypes.UnaryOp:{m(s,p);break}case n.TokenTypes.BinaryOp:{O(s,p);break}}p.index++}return e}t.parse=r;class l{constructor(e,p){this.type=e,this.precedence=p}clone(){const e=Object.create(Object.getPrototypeOf(this));return Object.defineProperties(e,Object.getOwnPropertyDescriptors(this)),e}}t.Tree=l;const f=-1,c=Number.MAX_SAFE_INTEGER+1,b=Number.MAX_SAFE_INTEGER;class y extends l{$content;set content(e){this.$content=e,e.parent=this}get content(){return this.$content}constructor(){super(n.TreeTypes.Root,f)}toString(){return this.content?this.content.toString():"<Empty>"}toJSON(){return this.content?.toJSON()??{}}}t.RootTree=y;class h extends l{constructor(e,p){super(n.TreeTypes.Numeral,c),this.parent=e,this.numToken=p}toString(){return`<Num> ${this.numToken}`}toJSON(){return{numeral:this.numToken.toJSON()}}}t.NumeralTree=h;class d extends l{constructor(e,p){super(n.TreeTypes.UnaryOp,b),this.parent=e,this.opToken=p,this.operator=a.getUnaryOpWithSymbol(p.symbol)}$argument;set argument(e){this.$argument=e,e.parent=this}get argument(){return this.$argument}operator;toString(e=1){const p=`
`+"  ┃  ".repeat(e);return`<Unary>${p}UOp: ${this.opToken} (${this.operator.id})${p}Arg: ${this.argument?this.argument.toString(e+1):"<Empty>"}`}toJSON(){return{operator:{...this.opToken.toJSON(),...this.operator,type:n.UnaryOpTypes[this.operator.type]},argument:this.argument?.toJSON()??{}}}}t.UnaryOpTree=d;class k extends l{constructor(e,p){const s=a.getBinaryOpWithSymbol(p.symbol);super(n.TreeTypes.BinaryOp,s.precedence),this.parent=e,this.opToken=p,this.operator=s}$left;$right;set left(e){this.$left=e,e.parent=this}get left(){return this.$left}set right(e){this.$right=e,e.parent=this}get right(){return this.$right}operator;toString(e=1){const p=`
`+"  ┃  ".repeat(e);return`<Binary>${p}BOp: ${this.opToken} (${this.operator.id})${p}Lft: ${this.left?this.left.toString(e+1):"<Empty>"}${p}Rgt: ${this.right?this.right.toString(e+1):"<Empty>"}`}toJSON(){return{operator:{...this.opToken.toJSON(),...this.operator},left:this.left?.toJSON()??{},right:this.right?.toJSON()??{}}}}t.BinaryOpTree=k;function U(i,e){if(i.symbol===")")throw new SyntaxError(`Lone right bracket at ${e.position()}.`);if(e.pointer.type===n.TreeTypes.Numeral)throw new SyntaxError(`Missing operator before bracket at ${e.position()}.`);const p=e.index;let s=p,T=1;for(;s<e.tokens.length-1&&(s++,!(e.tokens[s].type===n.TokenTypes.Bracket&&(e.tokens[s].symbol==="("?T++:T--,T===0))););if(T!==0)throw new SyntaxError(`Unbalanced bracket at ${e.position()}.`);if(s===p+1)throw new SyntaxError(`Empty brackets at ${e.position()}.`);e.index=s;const o=r(e.tokens.slice(p+1,s));switch(o.content.precedence=c,e.pointer.type){case n.TreeTypes.Root:{const g=e.pointer;e.pointer=g.content=o.content;break}case n.TreeTypes.UnaryOp:{const g=e.pointer;e.pointer=g.argument=o.content;break}case n.TreeTypes.BinaryOp:{const g=e.pointer;e.pointer=g.right=o.content;break}}}function u(i,e){if(e.pointer.type===n.TreeTypes.Numeral)throw new SyntaxError(`Missing operator between numerals at ${e.position()}.`);const p=new h(e.pointer,i);switch(e.pointer.type){case n.TreeTypes.Root:{const s=e.pointer;e.pointer=s.content=p;break}case n.TreeTypes.UnaryOp:{const s=e.pointer;e.pointer=s.argument=p;break}case n.TreeTypes.BinaryOp:{const s=e.pointer;e.pointer=s.right=p;break}}}function m(i,e){for(;e.pointer.type!==n.TreeTypes.Root&&e.pointer.precedence>b;)e.pointer=e.pointer.parent;const s=a.getUnaryOpWithSymbol(i.symbol).type===n.UnaryOpTypes.Postfix;if(s&&!(e.pointer.type===n.TreeTypes.Root&&e.pointer.content||e.pointer.type===n.TreeTypes.UnaryOp&&e.pointer.argument||e.pointer.type===n.TreeTypes.BinaryOp&&e.pointer.right))throw new SyntaxError(`Missing entry before postfix unary operator at ${e.position()}.`);const T=new d(e.pointer,i);switch(e.pointer.type){case n.TreeTypes.Root:{const o=e.pointer;s&&(T.argument=o.content.clone()),e.pointer=o.content=T;break}case n.TreeTypes.UnaryOp:{const o=e.pointer;s&&(T.argument=o.argument.clone()),e.pointer=o.argument=T;break}case n.TreeTypes.BinaryOp:{const o=e.pointer;s&&(T.argument=o.right.clone()),e.pointer=o.right=T;break}}}function O(i,e){if(e.pointer.type===n.TreeTypes.Root)throw new SyntaxError(`Missing entry before binary operator at ${e.position()}.`);const p=a.getBinaryOpWithSymbol(i.symbol);for(;e.pointer.precedence>=p.precedence;)e.pointer=e.pointer.parent;const s=new k(e.pointer,i);switch(e.pointer.type){case n.TreeTypes.Root:{const T=e.pointer;s.left=T.content.clone(),e.pointer=T.content=s;break}case n.TreeTypes.UnaryOp:{const T=e.pointer;s.left=T.clone(),e.pointer=T.argument=s;break}case n.TreeTypes.BinaryOp:{const T=e.pointer;s.left=T.right.clone(),e.pointer=T.right=s;break}}}})(N||(N={}));var M;(t=>{function r(y){switch(y.type){case n.TreeTypes.Root:return l(y);case n.TreeTypes.Numeral:return f(y);case n.TreeTypes.UnaryOp:return c(y);case n.TreeTypes.BinaryOp:return b(y)}}t.evaluate=r;function l(y){if(!y.content)throw new SyntaxError("Evaluating empty tree.");return r(y.content)}function f(y){const h=y.numToken.symbol;return a.existConstantWithSymbol(h)?a.getConstantWithSymbol(h).value:Number(h)}function c(y){if(!y.argument)throw new SyntaxError(`Unary operator lacks argument at ${y.opToken.position}.`);const h=a.getUnaryOpWithSymbol(y.operator.symbol).callback;return h(r(y.argument))}function b(y){if(!y.left)throw new SyntaxError(`Binary operator lacks left operand at ${y.opToken.position}.`);if(!y.right)throw new SyntaxError(`Binary operator lacks right operand at ${y.opToken.position}.`);const h=a.getBinaryOpWithSymbol(y.operator.symbol).callback,d=r(y.left),k=r(y.right);return h(d,k)}})(M||(M={}));var C;(t=>{function r(f){const c=$.tokenize(f),b=N.parse(c),y=M.evaluate(b);return{tokens:c,tree:b,value:y}}t.calculate=r;function l(f){return r(f).value}t.value=l})(C||(C={}));const v=50,E=document.getElementById("input"),w=document.getElementById("result");P(E.getAttribute("placeholder"));E.oninput=()=>P(E.value);function P(t){console.clear(),w.classList.remove("error");let r,l;try{const f=performance.now();r=C.calculate(t.length===0?E.getAttribute("placeholder"):t),l=performance.now()-f}catch(f){w.innerHTML="",w.classList.add("error");const c=document.createElement("p");c.textContent=`${f}`.replace(/.*Error: /,""),w.appendChild(c);return}console.log(`Calculated in ${l}ms.`),console.log("<AST>",r.tree.toJSON()),console.log(`${r.tree}`),R(r.tokens,r.value)}function R(t,r){if(w.innerHTML="",t.reduce((c,b)=>c+b.symbol.length,0)>v){const c=document.createElement("p");c.textContent="Expression",w.appendChild(c)}else for(const c of t){const b=document.createElement("p");b.textContent=c.symbol,b.className=n.TokenTypes[c.type],w.appendChild(b)}const l=document.createElement("p");l.textContent=" = ",w.appendChild(l);const f=document.createElement("p");f.textContent=`${r}`,w.appendChild(f)}
