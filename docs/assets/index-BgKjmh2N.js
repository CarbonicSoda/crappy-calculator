(function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))i(n);new MutationObserver(n=>{for(const a of n)if(a.type==="childList")for(const u of a.addedNodes)u.tagName==="LINK"&&u.rel==="modulepreload"&&i(u)}).observe(document,{childList:!0,subtree:!0});function e(n){const a={};return n.integrity&&(a.integrity=n.integrity),n.referrerPolicy&&(a.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?a.credentials="include":n.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function i(n){if(n.ep)return;n.ep=!0;const a=e(n);fetch(n.href,a)}})();const w=4;var o=(t=>(t[t.Bracket=0]="Bracket",t[t.UnaryOperator=1]="UnaryOperator",t[t.BinaryOperator=2]="BinaryOperator",t[t.Numeral=3]="Numeral",t))(o||{}),y=(t=>(t[t.Left=0]="Left",t[t.Right=1]="Right",t))(y||{}),m=(t=>(t[t.Pos=0]="Pos",t[t.Neg=1]="Neg",t))(m||{}),s=(t=>(t[t.Add=0]="Add",t[t.Sub=1]="Sub",t[t.Mul=2]="Mul",t[t.Div=3]="Div",t[t.Pow=4]="Pow",t))(s||{}),c=(t=>(t[t.Unset=0]="Unset",t[t.Numeral=1]="Numeral",t[t.Unary=2]="Unary",t[t.Binary=3]="Binary",t))(c||{});function v(t){const r=t.length,e=[];for(;t.length;){const i=r-t.length,n=B(t,e,i);if(!n)throw new SyntaxError(`Unknown symbol at index ${i}.`);t=t.slice(n.length)}return e}const U={[o.Bracket]:/[\(\)]/,[o.UnaryOperator]:/[\+\-]/,[o.BinaryOperator]:/[\+\-\*\/\^]/,[o.Numeral]:/\d+(?:\.\d+)?(?:[eE](?:[\+\-])?\d+)?/};function B(t,r,e){let i;for(let n=0;n<w;n++){const a=new RegExp(`^\\s*${U[n].source}\\s*`);if(i=t.match(a)?.[0],!i)continue;const u=i.trim();switch(n){case o.Bracket:{const l=u==="("?y.Left:y.Right,f=r.at(-1);(f?.type===o.Numeral||f?.type===o.Bracket&&f.value===y.Right)&&l===y.Left&&r.push({type:o.BinaryOperator,value:s.Mul,index:e}),r.push({type:o.Bracket,value:l,index:e});break}case o.UnaryOperator:{const l=r.at(-1);if(l?.type===void 0||l?.type===o.Bracket&&l.value===y.Left||l?.type===o.UnaryOperator||l?.type===o.BinaryOperator){r.push({type:o.UnaryOperator,value:u==="-"?m.Neg:m.Pos,index:e});break}}case o.BinaryOperator:{r.push({type:o.BinaryOperator,value:{"+":s.Add,"-":s.Sub,"*":s.Mul,"/":s.Div,"^":s.Pow}[u],index:e});break}case o.Numeral:{r.push({type:o.Numeral,value:Number(u),index:e});break}}break}return i}function k(t){if(t.length===1){const n=t[0];if(n.type!==o.Numeral)throw new SyntaxError("Invalid single token.");return d(c.Numeral,{numeral:n})}const r={kind:c.Unset,content:{}};let e=r,i=0;for(;i<t.length;){const n=t[i];switch(n.type){case o.Bracket:{const a=N(t,i),u=k(t.slice(i+1,a));switch(i=a,e.kind){case c.Unset:{if(i===t.length-1){e.kind=u.kind,e.content=u.content;break}e.kind=c.Binary,e.content=d(c.Binary,{left:u}).content;break}case c.Unary:{e.content.argument=u;break}case c.Binary:{e.content.right=u;break}}break}case o.UnaryOperator:{const a=d(c.Unary,{operator:n});switch(e.kind){case c.Unset:{e.kind=c.Unary,e.content=a.content;break}case c.Unary:{e.content.argument=a,e=a;break}case c.Binary:{e.content.right=a,e=a;break}}break}case o.BinaryOperator:{if(e.kind===c.Unset)throw new SyntaxError("Binary operator at start of expression.");const a=n;if(e.kind===c.Binary&&!e.content.operator){e.content.operator=a;break}const u=a.value===s.Add||a.value===s.Sub,l=e.kind===c.Unary,f=d(c.Binary,{left:structuredClone(u||l?e:e.content.right),operator:a});if(u||l){e.kind=c.Binary,e.content=f.content;break}e.content.right=f,e=f;break}case o.Numeral:{const a=d(c.Numeral,{numeral:n});switch(e.kind){case c.Unset:{e.kind=c.Binary,e.content=d(c.Binary,{left:a}).content;break}case c.Unary:{e.content.argument=a;break}case c.Binary:{e.content.right=a;break}}break}}i++}return r}function N(t,r){let e=r,i=1;for(;e<t.length&&(e++,!(t[e].type===o.Bracket&&(t[e].value===y.Left?i++:i--,i===0))););if(i!==0)throw new SyntaxError(`No matching right bracket for left bracket at index ${r}`);if(e===r+1)throw new SyntaxError(`Empty brackets at index ${r}.`);return e}function d(t,r){return{kind:t,content:r}}function g(t){switch(t.kind){case c.Numeral:return t.content.numeral.value;case c.Unary:{const r=g(t.content.argument);return t.content.operator.value===m.Pos?r:-r}case c.Binary:{const r=g(t.content.left),e=g(t.content.right);switch(t.content.operator.value){case s.Add:return r+e;case s.Sub:return r-e;case s.Mul:return r*e;case s.Div:return r/e;case s.Pow:return r**e}}default:throw new SyntaxError(`AST not defined: ${JSON.stringify(t)}`)}}function b(t){return g(k(v(t)))}const h=document.getElementById("calc"),p=document.getElementById("res");p.textContent=String(b(h.getAttribute("placeholder")));h.oninput=()=>{if(h.value.length===0){p.textContent=String(b(h.getAttribute("placeholder")));return}try{p.textContent=String(b(h.value))}catch{p.textContent="Invalid Input"}};
