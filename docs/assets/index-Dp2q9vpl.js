(function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const h of document.querySelectorAll('link[rel="modulepreload"]'))f(h);new MutationObserver(h=>{for(const l of h)if(l.type==="childList")for(const g of l.addedNodes)g.tagName==="LINK"&&g.rel==="modulepreload"&&f(g)}).observe(document,{childList:!0,subtree:!0});function p(h){const l={};return h.integrity&&(l.integrity=h.integrity),h.referrerPolicy&&(l.referrerPolicy=h.referrerPolicy),h.crossOrigin==="use-credentials"?l.credentials="include":h.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function f(h){if(h.ep)return;h.ep=!0;const l=p(h);fetch(h.href,l)}})();var n;(t=>{(r=>{r[r.Prefix=0]="Prefix",r[r.Postfix=1]="Postfix",r[r.Function=2]="Function"})(t.UnaryOpTypes||(t.UnaryOpTypes={})),(r=>{r[r.Bracket=0]="Bracket",r[r.Numeral=1]="Numeral",r[r.UnaryOp=2]="UnaryOp",r[r.BinaryOp=3]="BinaryOp"})(t.TokenTypes||(t.TokenTypes={})),(r=>{r[r.Root=0]="Root",r[r.Numeral=1]="Numeral",r[r.UnaryOp=2]="UnaryOp",r[r.BinaryOp=3]="BinaryOp"})(t.TreeTypes||(t.TreeTypes={}))})(n||(n={}));var s;(t=>{t.constantRegistry=new Map,t.constantSymbolRegistry=new Map,t.unaryOpRegistry=new Map,t.unaryOpSymbolRegistry=new Map,t.binaryOpRegistry=new Map,t.binaryOpSymbolRegistry=new Map;function r(o){return t.constantRegistry.has(o)}t.existConstant=r;function p(o){return t.constantSymbolRegistry.has(o)}t.existConstantWithSymbol=p;function f(o){return t.unaryOpRegistry.has(o)}t.existUnaryOp=f;function h(o){return t.unaryOpSymbolRegistry.has(o)}t.existUnaryOpWithSymbol=h;function l(o){return t.binaryOpRegistry.has(o)}t.existBinaryOp=l;function g(o){return t.binaryOpSymbolRegistry.has(o)}t.existBinaryOpWithSymbol=g;function a(o,O){if(r(o))throw new Error(`Constant with id ${o} already exists.`);if(p(O.symbol))throw new Error(`Constant with symbol ${O.symbol} already exists.`);t.constantRegistry.set(o,{id:o,...O}),t.constantSymbolRegistry.set(O.symbol,{id:o,...O})}t.registerConstant=a;function d(o,O){if(f(o))throw new Error(`Unary operator with id ${o} already exists.`);if(h(O.symbol))throw new Error(`Unary operator with symbol ${O.symbol} already exists.`);t.unaryOpRegistry.set(o,{id:o,...O}),t.unaryOpSymbolRegistry.set(O.symbol,{id:o,...O})}t.registerUnaryOp=d;function w(o,O){if(l(o))throw new Error(`Binary operator with id ${o} already exists.`);if(g(O.symbol))throw new Error(`Binary operator with symbol ${O.symbol} already exists.`);t.binaryOpRegistry.set(o,{id:o,...O}),t.binaryOpSymbolRegistry.set(O.symbol,{id:o,...O})}t.registerBinaryOp=w;function U(){return[...t.constantSymbolRegistry.keys()]}t.getConstantSymbols=U;function u(){return[...t.unaryOpSymbolRegistry.keys()]}t.getUnaryOpSymbols=u;function m(){return[...t.binaryOpSymbolRegistry.keys()]}t.getBinaryOpSymbols=m;function b(o){if(!r(o))throw new Error(`Constant with id ${o} is not registered.`);return t.constantRegistry.get(o)}t.getConstant=b;function y(o){if(!p(o))throw new Error(`Constant with symbol ${o} is not registered.`);return t.constantSymbolRegistry.get(o)}t.getConstantWithSymbol=y;function e(o){if(!f(o))throw new Error(`Unary operator with id ${o} is not registered.`);return t.unaryOpRegistry.get(o)}t.getUnaryOp=e;function c(o){if(!h(o))throw new Error(`Unary operator with symbol ${o} is not registered.`);return t.unaryOpSymbolRegistry.get(o)}t.getUnaryOpWithSymbol=c;function i(o){if(!l(o))throw new Error(`Binary operator with id ${o} is not registered.`);return t.binaryOpRegistry.get(o)}t.getBinaryOp=i;function T(o){if(!g(o))throw new Error(`Binary operator with symbol ${o} is not registered.`);return t.binaryOpSymbolRegistry.get(o)}t.getBinaryOpWithSymbol=T})(s||(s={}));var E;(t=>{function p(a){if(a===1/0)return 1/0;if(a>=0&&a<100&&Number.isInteger(a)){let d=1;for(let w=2;w<a+1;w++)d*=w;return d}return h(a+1)}t.factorial=p;function f(a){return p(a-1)}t.gamma=f;function h(a){const w=[.9999999999998099,676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,15056327351493116e-23];if(a<.5)return Math.PI/(Math.sin(Math.PI*a)*h(1-a));a--;let U=w[0];for(let b=1;b<9;b++)U+=w[b]/(a+b);const u=a+7+.5,m=Math.pow(u,a+.5);return m===1/0?1/0:Math.sqrt(2*Math.PI)*m*Math.exp(-u)*U}function l(a,d){return p(a)/p(a-d)}t.permutation=l;function g(a,d){return l(a,d)/p(d)}t.combination=g})(E||(E={}));function P(){s.registerConstant("e",{symbol:"E",value:Math.E}),s.registerConstant("pi",{symbol:"PI",value:Math.PI}),s.registerUnaryOp("pos",{symbol:"+",type:n.UnaryOpTypes.Prefix,callback:r=>r}),s.registerUnaryOp("neg",{symbol:"-",type:n.UnaryOpTypes.Prefix,callback:r=>-r}),s.registerUnaryOp("factorial",{symbol:"!",type:n.UnaryOpTypes.Postfix,callback:E.factorial}),s.registerUnaryOp("abs",{symbol:"abs",type:n.UnaryOpTypes.Function,callback:Math.abs}),s.registerUnaryOp("floor",{symbol:"floor",type:n.UnaryOpTypes.Function,callback:Math.floor}),s.registerUnaryOp("ceil",{symbol:"ceil",type:n.UnaryOpTypes.Function,callback:Math.ceil}),s.registerUnaryOp("round",{symbol:"round",type:n.UnaryOpTypes.Function,callback:Math.round}),s.registerUnaryOp("sqrt",{symbol:"sqrt",type:n.UnaryOpTypes.Function,callback:Math.sqrt}),s.registerUnaryOp("exp",{symbol:"exp",type:n.UnaryOpTypes.Function,callback:Math.exp}),s.registerUnaryOp("log",{symbol:"Ln",type:n.UnaryOpTypes.Function,callback:Math.log}),s.registerUnaryOp("log10",{symbol:"log",type:n.UnaryOpTypes.Function,callback:Math.log10}),s.registerUnaryOp("sin",{symbol:"sin",type:n.UnaryOpTypes.Function,callback:Math.sin}),s.registerUnaryOp("cos",{symbol:"cos",type:n.UnaryOpTypes.Function,callback:Math.cos}),s.registerUnaryOp("tan",{symbol:"tan",type:n.UnaryOpTypes.Function,callback:Math.tan}),s.registerUnaryOp("asin",{symbol:"asin",type:n.UnaryOpTypes.Function,callback:Math.asin}),s.registerUnaryOp("acos",{symbol:"acos",type:n.UnaryOpTypes.Function,callback:Math.acos}),s.registerUnaryOp("atan",{symbol:"atan",type:n.UnaryOpTypes.Function,callback:Math.atan}),s.registerUnaryOp("gamma",{symbol:"Gamma",type:n.UnaryOpTypes.Function,callback:E.gamma}),s.registerBinaryOp("add",{symbol:"+",callback:(r,p)=>r+p,precedence:0}),s.registerBinaryOp("sub",{symbol:"-",callback:(r,p)=>r-p,precedence:0}),s.registerBinaryOp("mul",{symbol:"*",callback:(r,p)=>r*p,precedence:1}),s.registerBinaryOp("div",{symbol:"/",callback:(r,p)=>r/p,precedence:1}),s.registerBinaryOp("int_div",{symbol:"//",callback:(r,p)=>Math.floor(r/p),precedence:1}),s.registerBinaryOp("pow",{symbol:"**",callback:(r,p)=>r**p,precedence:2}),s.registerBinaryOp("pow_alias",{symbol:"^",callback:(r,p)=>r**p,precedence:2}),s.registerBinaryOp("mod",{symbol:"%",callback:(r,p)=>r%p,precedence:2});const t=100;s.registerBinaryOp("min",{symbol:"min",callback:Math.min,precedence:t}),s.registerBinaryOp("max",{symbol:"max",callback:Math.max,precedence:t}),s.registerBinaryOp("permutation",{symbol:"P",callback:E.permutation,precedence:t}),s.registerBinaryOp("combination",{symbol:"C",callback:E.combination,precedence:t})}var x;(t=>{function r(u){const m=u.length,b=[];for(;u.length;){const y=m-u.length,e=g(u,y,b);u=u.slice(e.length)}return b}t.tokenize=r;class p{constructor(m,b,y){this.type=m,this.symbol=b,this.meta=y}toString(){return`Token[${this.meta.from}-${this.meta.to}]<${n.TokenTypes[this.type]}> ${this.symbol}`}}t.Token=p,P();const f=u=>u.replaceAll(/[.*+?^${}()|[\]\\]/g,"\\$&"),h=Object.keys(n.TokenTypes).length/2,l={[n.TokenTypes.Bracket]:/[()]/,[n.TokenTypes.Numeral]:new RegExp(`(?:${s.getConstantSymbols().sort((u,m)=>m.length-u.length).map(f).join(")|(?:")})|(?:\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)`),[n.TokenTypes.UnaryOp]:new RegExp(`(?:${s.getUnaryOpSymbols().sort((u,m)=>m.length-u.length).map(f).join(")|(?:")})`),[n.TokenTypes.BinaryOp]:new RegExp(`(?:${s.getBinaryOpSymbols().sort((u,m)=>m.length-u.length).map(f).join(")|(?:")})`)};function g(u,m,b){let y;for(let e=0;e<h;e++){const c=new RegExp(`^\\s*(?:${l[e].source})\\s*`);if(y=u.match(c)?.[0],y===void 0)continue;let i=y.trimStart();const T=m+y.length-i.length;i=i.trimEnd();const o=T+i.length-1,O={from:T,to:o},B=b.at(-1);switch(e){case n.TokenTypes.Bracket:{if(a(b,i,O,B))break;continue}case n.TokenTypes.Numeral:{if(d(b,i,O,B))break;continue}case n.TokenTypes.UnaryOp:{if(w(b,i,O,B))break;continue}case n.TokenTypes.BinaryOp:{if(U(b,i,O))break;continue}}break}if(!y)throw new SyntaxError(`Invalid symbol at ${m}.`);return y}function a(u,m,b,y){const e=y?.symbol===")"||y?.type===n.TokenTypes.Numeral||y?.type===n.TokenTypes.UnaryOp&&s.getUnaryOpWithSymbol(y.symbol).type===n.UnaryOpTypes.Postfix;if(m==="("&&e&&s.existBinaryOp("mul")){const i=new p(n.TokenTypes.BinaryOp,s.getBinaryOp("mul").symbol,b);u.push(i)}const c=new p(n.TokenTypes.Bracket,m,b);return u.push(c)}function d(u,m,b,y){const e=y?.symbol===")"||y?.type===n.TokenTypes.Numeral||y?.type===n.TokenTypes.UnaryOp&&s.getUnaryOpWithSymbol(y.symbol).type===n.UnaryOpTypes.Postfix;if(s.existConstantWithSymbol(m)&&e&&s.existBinaryOp("mul")){const i=new p(n.TokenTypes.BinaryOp,s.getBinaryOp("mul").symbol,b);u.push(i)}const c=new p(n.TokenTypes.Numeral,m,b);return u.push(c)}function w(u,m,b,y){const e=y?.symbol===")"||y?.type===n.TokenTypes.Numeral||y?.type===n.TokenTypes.UnaryOp&&s.getUnaryOpWithSymbol(y.symbol).type===n.UnaryOpTypes.Postfix;switch(s.getUnaryOpWithSymbol(m).type){case n.UnaryOpTypes.Prefix:{if(e)return!1;break}case n.UnaryOpTypes.Postfix:{if(!e)return!1;break}case n.UnaryOpTypes.Function:{if(!e||!s.existBinaryOp("mul"))break;const i=new p(n.TokenTypes.BinaryOp,s.getBinaryOp("mul").symbol,b);u.push(i);break}}const c=new p(n.TokenTypes.UnaryOp,m,b);return u.push(c)}function U(u,m,b,y){const e=new p(n.TokenTypes.BinaryOp,m,b);return u.push(e)}})(x||(x={}));var $;(t=>{function r(y){const e=new g,c={index:0,position:()=>{const i=c.tokens[c.index];return`${i.meta.from} - ${i.meta.to}`},tokens:y,pointer:e};for(;c.index<y.length;){const i=y[c.index];switch(i.type){case n.TokenTypes.Bracket:{U(i,c);break}case n.TokenTypes.Numeral:{u(i,c);break}case n.TokenTypes.UnaryOp:{m(i,c);break}case n.TokenTypes.BinaryOp:{b(i,c);break}}c.index++}return e}t.parse=r;class p{constructor(e,c){this.type=e,this.precedence=c}clone(){const e=Object.create(Object.getPrototypeOf(this));return Object.defineProperties(e,Object.getOwnPropertyDescriptors(this)),e}}t.Tree=p;const f=-1,h=Number.MAX_SAFE_INTEGER+1,l=Number.MAX_SAFE_INTEGER;class g extends p{$content;set content(e){this.$content=e,e.parent=this}get content(){return this.$content}constructor(){super(n.TreeTypes.Root,f)}toString(){return`${this.content?this.content.toString():"<Empty>"}`}}t.RootTree=g;class a extends p{constructor(e,c){super(n.TreeTypes.Numeral,h),this.parent=e,this.numeral=c}toString(e=1){return`Tree<Numeral>${`
`+"  ┃  ".repeat(e)}${this.numeral}`}}t.NumeralTree=a;class d extends p{constructor(e,c){super(n.TreeTypes.UnaryOp,l),this.parent=e,this.operator=s.getUnaryOpWithSymbol(c.symbol),this.meta=c.meta}$argument;set argument(e){this.$argument=e,e.parent=this}get argument(){return this.$argument}operator;meta;toString(e=1){const c=`
`+"  ┃  ".repeat(e);return`Tree<Unary>${c}Operator: ${this.operator.id} (${this.operator.symbol})${c}Argument: ${this.argument?this.argument.toString(e+1):"<Empty>"}`}}t.UnaryOpTree=d;class w extends p{constructor(e,c){const i=s.getBinaryOpWithSymbol(c.symbol);super(n.TreeTypes.BinaryOp,i.precedence),this.parent=e,this.operator=i,this.meta=c.meta}$left;$right;set left(e){this.$left=e,e.parent=this}get left(){return this.$left}set right(e){this.$right=e,e.parent=this}get right(){return this.$right}operator;meta;toString(e=1){const c=`
`+"  ┃  ".repeat(e);return`Tree<Binary>${c}Operator: ${this.operator.id} (${this.operator.symbol})${c}Left: ${this.left?this.left.toString(e+1):"<Empty>"}${c}Right: ${this.right?this.right.toString(e+1):"<Empty>"}`}}t.BinaryOpTree=w;function U(y,e){if(y.symbol===")")throw new SyntaxError(`Lone right bracket at ${e.position()}.`);if(e.pointer.type===n.TreeTypes.Numeral)throw new SyntaxError(`Missing operator before bracket at ${e.position()}.`);const c=e.index;let i=c,T=1;for(;i<e.tokens.length-1&&(i++,!(e.tokens[i].type===n.TokenTypes.Bracket&&(e.tokens[i].symbol==="("?T++:T--,T===0))););if(T!==0)throw new SyntaxError(`Unbalanced bracket at ${e.position()}.`);if(i===c+1)throw new SyntaxError(`Empty brackets at ${e.position()}.`);e.index=i;const o=r(e.tokens.slice(c+1,i));switch(o.content.precedence=h,e.pointer.type){case n.TreeTypes.Root:{const O=e.pointer;e.pointer=O.content=o.content;break}case n.TreeTypes.UnaryOp:{const O=e.pointer;e.pointer=O.argument=o.content;break}case n.TreeTypes.BinaryOp:{const O=e.pointer;e.pointer=O.right=o.content;break}}}function u(y,e){if(e.pointer.type===n.TreeTypes.Numeral)throw new SyntaxError(`Missing operator between numerals at ${e.position()}.`);const c=new a(e.pointer,y);switch(e.pointer.type){case n.TreeTypes.Root:{const i=e.pointer;e.pointer=i.content=c;break}case n.TreeTypes.UnaryOp:{const i=e.pointer;e.pointer=i.argument=c;break}case n.TreeTypes.BinaryOp:{const i=e.pointer;e.pointer=i.right=c;break}}}function m(y,e){for(;e.pointer.type!==n.TreeTypes.Root&&e.pointer.precedence>l;)e.pointer=e.pointer.parent;const i=s.getUnaryOpWithSymbol(y.symbol).type===n.UnaryOpTypes.Postfix;if(i&&!(e.pointer.type===n.TreeTypes.Root&&e.pointer.content||e.pointer.type===n.TreeTypes.UnaryOp&&e.pointer.argument||e.pointer.type===n.TreeTypes.BinaryOp&&e.pointer.right))throw new SyntaxError(`Missing entry before postfix unary operator at ${e.position()}.`);const T=new d(e.pointer,y);switch(e.pointer.type){case n.TreeTypes.Root:{const o=e.pointer;i&&(T.argument=o.content.clone()),e.pointer=o.content=T;break}case n.TreeTypes.UnaryOp:{const o=e.pointer;i&&(T.argument=o.argument.clone()),e.pointer=o.argument=T;break}case n.TreeTypes.BinaryOp:{const o=e.pointer;i&&(T.argument=o.right.clone()),e.pointer=o.right=T;break}}}function b(y,e){if(e.pointer.type===n.TreeTypes.Root)throw new SyntaxError(`Missing entry before binary operator at ${e.position()}.`);const c=s.getBinaryOpWithSymbol(y.symbol);for(;e.pointer.precedence>=c.precedence;)e.pointer=e.pointer.parent;const i=new w(e.pointer,y);switch(e.pointer.type){case n.TreeTypes.Root:{const T=e.pointer;i.left=T.content.clone(),e.pointer=T.content=i;break}case n.TreeTypes.UnaryOp:{const T=e.pointer;i.left=T.clone(),e.pointer=T.argument=i;break}case n.TreeTypes.BinaryOp:{const T=e.pointer;i.left=T.right.clone(),e.pointer=T.right=i;break}}}})($||($={}));var M;(t=>{function r(a){switch(a.type){case n.TreeTypes.Root:return p(a);case n.TreeTypes.Numeral:return f(a);case n.TreeTypes.UnaryOp:return h(a);case n.TreeTypes.BinaryOp:return l(a)}}t.evaluate=r;function p(a){if(!a.content)throw new SyntaxError("Evaluating empty tree.");return r(a.content)}function f(a){const d=a.numeral.symbol;return s.existConstantWithSymbol(d)?s.getConstantWithSymbol(d).value:Number(d)}function h(a){if(!a.argument)throw new SyntaxError(`Unary operator lacks argument at ${g(a.meta)}.`);const d=s.getUnaryOpWithSymbol(a.operator.symbol).callback;return d(r(a.argument))}function l(a){if(!a.left)throw new SyntaxError(`Binary operator lacks left operand at ${g(a.meta)}.`);if(!a.right)throw new SyntaxError(`Binary operator lacks right operand at ${g(a.meta)}.`);const d=s.getBinaryOpWithSymbol(a.operator.symbol).callback,w=r(a.left),U=r(a.right);return d(w,U)}const g=a=>`${a.from} - ${a.to}`})(M||(M={}));var C;(t=>{function r(f){const h=x.tokenize(f),l=$.parse(h),g=M.evaluate(l);return{tokens:h,tree:l,value:g}}t.calculate=r;function p(f){return r(f).value}t.value=p})(C||(C={}));const v=50,S=document.getElementById("input"),k=document.getElementById("result");N(S.getAttribute("placeholder"));S.oninput=()=>N(S.value);function N(t){console.clear(),k.classList.remove("error");let r;try{r=C.calculate(t.length===0?S.getAttribute("placeholder"):t)}catch(p){k.innerHTML="",k.classList.add("error");const f=document.createElement("p");f.textContent=`${p}`.replace(/.*Error: /,""),k.appendChild(f);return}console.log(`${r.tree}`),R(r.tokens,r.value)}function R(t,r){if(k.innerHTML="",(l=>{let g=0;for(const a of l)g+=a;return g})(t.map(l=>l.symbol.length))>v){const l=document.createElement("p");l.textContent="Expression",k.appendChild(l)}else for(const l of t){const g=document.createElement("p");g.textContent=l.symbol,g.className=n.TokenTypes[l.type],k.appendChild(g)}const f=document.createElement("p");f.textContent=" = ",k.appendChild(f);const h=document.createElement("p");h.textContent=`${r}`,k.appendChild(h)}
