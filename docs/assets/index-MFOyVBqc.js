(function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const l of document.querySelectorAll('link[rel="modulepreload"]'))g(l);new MutationObserver(l=>{for(const u of l)if(u.type==="childList")for(const d of u.addedNodes)d.tagName==="LINK"&&d.rel==="modulepreload"&&g(d)}).observe(document,{childList:!0,subtree:!0});function c(l){const u={};return l.integrity&&(u.integrity=l.integrity),l.referrerPolicy&&(u.referrerPolicy=l.referrerPolicy),l.crossOrigin==="use-credentials"?u.credentials="include":l.crossOrigin==="anonymous"?u.credentials="omit":u.credentials="same-origin",u}function g(l){if(l.ep)return;l.ep=!0;const u=c(l);fetch(l.href,u)}})();var n;(t=>{(r=>{r[r.Prefix=0]="Prefix",r[r.Postfix=1]="Postfix",r[r.Function=2]="Function"})(t.UnaryOpTypes||(t.UnaryOpTypes={})),(r=>{r[r.Bracket=0]="Bracket",r[r.Numeral=1]="Numeral",r[r.UnaryOp=2]="UnaryOp",r[r.BinaryOp=3]="BinaryOp"})(t.TokenTypes||(t.TokenTypes={})),(r=>{r[r.Root=0]="Root",r[r.Numeral=1]="Numeral",r[r.UnaryOp=2]="UnaryOp",r[r.BinaryOp=3]="BinaryOp"})(t.TreeTypes||(t.TreeTypes={}))})(n||(n={}));var p;(t=>{t.constantRegistry=new Map,t.constantSymbolRegistry=new Map,t.unaryOpRegistry=new Map,t.unaryOpSymbolRegistry=new Map,t.binaryOpRegistry=new Map,t.binaryOpSymbolRegistry=new Map;function r(o){return t.constantRegistry.has(o)}t.existConstant=r;function c(o){return t.constantSymbolRegistry.has(o)}t.existConstantWithSymbol=c;function g(o){return t.unaryOpRegistry.has(o)}t.existUnaryOp=g;function l(o){return t.unaryOpSymbolRegistry.has(o)}t.existUnaryOpWithSymbol=l;function u(o){return t.binaryOpRegistry.has(o)}t.existBinaryOp=u;function d(o){return t.binaryOpSymbolRegistry.has(o)}t.existBinaryOpWithSymbol=d;function a(o,b){if(r(o))throw new Error(`Constant with id ${o} already exists.`);if(c(b.symbol))throw new Error(`Constant with symbol ${b.symbol} already exists.`);t.constantRegistry.set(o,b),t.constantSymbolRegistry.set(b.symbol,b)}t.registerConstant=a;function T(o,b){if(g(o))throw new Error(`Unary operator with id ${o} already exists.`);if(l(b.symbol))throw new Error(`Unary operator with symbol ${b.symbol} already exists.`);t.unaryOpRegistry.set(o,b),t.unaryOpSymbolRegistry.set(b.symbol,b)}t.registerUnaryOp=T;function w(o,b){if(u(o))throw new Error(`Binary operator with id ${o} already exists.`);if(d(b.symbol))throw new Error(`Binary operator with symbol ${b.symbol} already exists.`);t.binaryOpRegistry.set(o,b),t.binaryOpSymbolRegistry.set(b.symbol,b)}t.registerBinaryOp=w;function E(){return[...t.constantSymbolRegistry.keys()]}t.getConstantSymbols=E;function h(){return[...t.unaryOpSymbolRegistry.keys()]}t.getUnaryOpSymbols=h;function m(){return[...t.binaryOpSymbolRegistry.keys()]}t.getBinaryOpSymbols=m;function O(o){if(!r(o))throw new Error(`Constant with id ${o} is not registered.`);return t.constantRegistry.get(o)}t.getConstant=O;function y(o){if(!c(o))throw new Error(`Constant with symbol ${o} is not registered.`);return t.constantSymbolRegistry.get(o)}t.getConstantWithSymbol=y;function e(o){if(!g(o))throw new Error(`Unary operator with id ${o} is not registered.`);return t.unaryOpRegistry.get(o)}t.getUnaryOp=e;function i(o){if(!l(o))throw new Error(`Unary operator with symbol ${o} is not registered.`);return t.unaryOpSymbolRegistry.get(o)}t.getUnaryOpWithSymbol=i;function s(o){if(!u(o))throw new Error(`Binary operator with id ${o} is not registered.`);return t.binaryOpRegistry.get(o)}t.getBinaryOp=s;function f(o){if(!d(o))throw new Error(`Binary operator with symbol ${o} is not registered.`);return t.binaryOpSymbolRegistry.get(o)}t.getBinaryOpWithSymbol=f})(p||(p={}));var U;(t=>{function c(a){if(a>=0&&a<100&&Number.isInteger(a)){let T=1;for(let w=2;w<a+1;w++)T*=w;return T}return l(a+1)}t.factorial=c;function g(a){return c(a-1)}t.gamma=g;function l(a){const w=[.9999999999998099,676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,15056327351493116e-23];if(a<.5)return Math.PI/(Math.sin(Math.PI*a)*l(1-a));a--;let E=w[0];for(let m=1;m<9;m++)E+=w[m]/(a+m);const h=a+7+.5;return Math.sqrt(2*Math.PI)*Math.pow(h,a+.5)*Math.exp(-h)*E}function u(a,T){return c(a)/c(a-T)}t.permutation=u;function d(a,T){return u(a,T)/c(T)}t.combination=d})(U||(U={}));function P(){p.registerConstant("e",{symbol:"E",value:Math.E}),p.registerConstant("pi",{symbol:"PI",value:Math.PI}),p.registerUnaryOp("pos",{symbol:"+",type:n.UnaryOpTypes.Prefix,callback:r=>r}),p.registerUnaryOp("neg",{symbol:"-",type:n.UnaryOpTypes.Prefix,callback:r=>-r}),p.registerUnaryOp("factorial",{symbol:"!",type:n.UnaryOpTypes.Postfix,callback:U.factorial}),p.registerUnaryOp("abs",{symbol:"abs",type:n.UnaryOpTypes.Function,callback:Math.abs}),p.registerUnaryOp("sqrt",{symbol:"sqrt",type:n.UnaryOpTypes.Function,callback:Math.sqrt}),p.registerUnaryOp("exp",{symbol:"exp",type:n.UnaryOpTypes.Function,callback:Math.exp}),p.registerUnaryOp("log",{symbol:"Ln",type:n.UnaryOpTypes.Function,callback:Math.log}),p.registerUnaryOp("log10",{symbol:"log",type:n.UnaryOpTypes.Function,callback:Math.log10}),p.registerUnaryOp("sin",{symbol:"sin",type:n.UnaryOpTypes.Function,callback:Math.sin}),p.registerUnaryOp("cos",{symbol:"cos",type:n.UnaryOpTypes.Function,callback:Math.cos}),p.registerUnaryOp("tan",{symbol:"tan",type:n.UnaryOpTypes.Function,callback:Math.tan}),p.registerUnaryOp("gamma",{symbol:"Gamma",type:n.UnaryOpTypes.Function,callback:U.gamma}),p.registerBinaryOp("add",{symbol:"+",callback:(r,c)=>r+c,precedence:0}),p.registerBinaryOp("sub",{symbol:"-",callback:(r,c)=>r-c,precedence:0}),p.registerBinaryOp("mul",{symbol:"*",callback:(r,c)=>r*c,precedence:1}),p.registerBinaryOp("div",{symbol:"/",callback:(r,c)=>r/c,precedence:1}),p.registerBinaryOp("pow",{symbol:"^",callback:(r,c)=>r**c,precedence:2}),p.registerBinaryOp("mod",{symbol:"%",callback:(r,c)=>r%c,precedence:2});const t=100;p.registerBinaryOp("min",{symbol:"min",callback:Math.min,precedence:t}),p.registerBinaryOp("max",{symbol:"max",callback:Math.max,precedence:t}),p.registerBinaryOp("permutation",{symbol:"P",callback:U.permutation,precedence:t}),p.registerBinaryOp("combination",{symbol:"C",callback:U.combination,precedence:t})}var B;(t=>{function r(h){const m=h.length,O=[];for(;h.length;){const y=m-h.length,e=d(h,y,O);h=h.slice(e.length)}return O}t.tokenize=r;class c{constructor(m,O,y){this.type=m,this.symbol=O,this.meta=y}toString(){return`Token[${this.meta.from}-${this.meta.to}]<${n.TokenTypes[this.type]}> ${this.symbol}`}}t.Token=c,P();const g=h=>h.replaceAll(/[.*+?^${}()|[\]\\]/g,"\\$&"),l=Object.keys(n.TokenTypes).length/2,u={[n.TokenTypes.Bracket]:/[()]/,[n.TokenTypes.Numeral]:new RegExp(`(?:${p.getConstantSymbols().sort((h,m)=>m.length-h.length).map(g).join(")|(?:")})|(?:\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)`),[n.TokenTypes.UnaryOp]:new RegExp(`(?:${p.getUnaryOpSymbols().sort((h,m)=>m.length-h.length).map(g).join(")|(?:")})`),[n.TokenTypes.BinaryOp]:new RegExp(`(?:${p.getBinaryOpSymbols().sort((h,m)=>m.length-h.length).map(g).join(")|(?:")})`)};function d(h,m,O){let y;for(let e=0;e<l;e++){const i=new RegExp(`^\\s*(?:${u[e].source})\\s*`);if(y=h.match(i)?.[0],y===void 0)continue;let s=y.trimStart();const f=m+y.length-s.length;s=s.trimEnd();const o=f+s.length-1,b={from:f,to:o},x=O.at(-1);switch(e){case n.TokenTypes.Bracket:{if(a(O,s,b,x))break;continue}case n.TokenTypes.Numeral:{if(T(O,s,b,x))break;continue}case n.TokenTypes.UnaryOp:{if(w(O,s,b,x))break;continue}case n.TokenTypes.BinaryOp:{if(E(O,s,b))break;continue}}break}if(!y)throw new SyntaxError(`Unknown symbol at position ${m}.`);return y}function a(h,m,O,y){const e=y?.symbol===")"||y?.type===n.TokenTypes.Numeral||y?.type===n.TokenTypes.UnaryOp&&p.getUnaryOpWithSymbol(y.symbol).type===n.UnaryOpTypes.Postfix;if(m==="("&&e&&p.existBinaryOp("mul")){const s=new c(n.TokenTypes.BinaryOp,p.getBinaryOp("mul").symbol,O);h.push(s)}const i=new c(n.TokenTypes.Bracket,m,O);return h.push(i)}function T(h,m,O,y){const e=y?.symbol===")"||y?.type===n.TokenTypes.Numeral||y?.type===n.TokenTypes.UnaryOp&&p.getUnaryOpWithSymbol(y.symbol).type===n.UnaryOpTypes.Postfix;if(p.existConstantWithSymbol(m)&&e&&p.existBinaryOp("mul")){const s=new c(n.TokenTypes.BinaryOp,p.getBinaryOp("mul").symbol,O);h.push(s)}const i=new c(n.TokenTypes.Numeral,m,O);return h.push(i)}function w(h,m,O,y){const e=y?.symbol===")"||y?.type===n.TokenTypes.Numeral||y?.type===n.TokenTypes.UnaryOp&&p.getUnaryOpWithSymbol(y.symbol).type===n.UnaryOpTypes.Postfix;switch(p.getUnaryOpWithSymbol(m).type){case n.UnaryOpTypes.Prefix:{if(e)return!1;break}case n.UnaryOpTypes.Postfix:{if(!e)return!1;break}case n.UnaryOpTypes.Function:{if(!e||!p.existBinaryOp("mul"))break;const s=new c(n.TokenTypes.BinaryOp,p.getBinaryOp("mul").symbol,O);h.push(s);break}}const i=new c(n.TokenTypes.UnaryOp,m,O);return h.push(i)}function E(h,m,O,y){const e=new c(n.TokenTypes.BinaryOp,m,O);return h.push(e)}})(B||(B={}));var $;(t=>{function r(y){const e=new d,i={index:0,position:()=>{const s=i.tokens[i.index];return`${s.meta.from} - ${s.meta.to}`},tokens:y,pointer:e};for(;i.index<y.length;){const s=y[i.index];switch(s.type){case n.TokenTypes.Bracket:{E(s,i);break}case n.TokenTypes.Numeral:{h(s,i);break}case n.TokenTypes.UnaryOp:{m(s,i);break}case n.TokenTypes.BinaryOp:{O(s,i);break}}i.index++}return e}t.parse=r;class c{constructor(e,i){this.type=e,this.precedence=i}clone(){const e=Object.create(Object.getPrototypeOf(this));return Object.defineProperties(e,Object.getOwnPropertyDescriptors(this)),e}}t.Tree=c;const g=-1,l=Number.MAX_SAFE_INTEGER+1,u=Number.MAX_SAFE_INTEGER;class d extends c{$content;set content(e){this.$content=e,e.parent=this}get content(){return this.$content}constructor(){super(n.TreeTypes.Root,g)}toString(){return`${this.content?this.content.toString():"<Empty>"}`}}t.RootTree=d;class a extends c{constructor(e,i){super(n.TreeTypes.Numeral,l),this.parent=e,this.numeral=i}toString(e=1){return`Tree<Numeral>${`
`+"  â”ƒ  ".repeat(e)}${this.numeral}`}}t.NumeralTree=a;class T extends c{constructor(e,i){super(n.TreeTypes.UnaryOp,u),this.parent=e,this.operatorToken=i,this.operator=p.getUnaryOpWithSymbol(i.symbol),this.meta=i.meta}$argument;set argument(e){this.$argument=e,e.parent=this}get argument(){return this.$argument}operator;meta;toString(e=1){const i=`
`+"  â”ƒ  ".repeat(e);return`Tree<Unary>${i}Operator: ${this.operatorToken}${i}Argument: ${this.argument?this.argument.toString(e+1):"<Empty>"}`}}t.UnaryOpTree=T;class w extends c{constructor(e,i){const s=p.getBinaryOpWithSymbol(i.symbol);super(n.TreeTypes.BinaryOp,s.precedence),this.parent=e,this.operatorToken=i,this.operator=s,this.meta=i.meta}$left;$right;set left(e){this.$left=e,e.parent=this}get left(){return this.$left}set right(e){this.$right=e,e.parent=this}get right(){return this.$right}operator;meta;toString(e=1){const i=`
`+"  â”ƒ  ".repeat(e);return`Tree<Binary>${i}Operator: ${this.operatorToken}${i}Left: ${this.left?this.left.toString(e+1):"<Empty>"}${i}Right: ${this.right?this.right.toString(e+1):"<Empty>"}`}}t.BinaryOpTree=w;function E(y,e){if(y.symbol===")")throw new SyntaxError(`Lone right bracket at ${e.position()}.`);if(e.pointer.type===n.TreeTypes.Numeral)throw new SyntaxError(`Missing operator before bracket at ${e.position()}.`);const i=e.index;let s=i,f=1;for(;s<e.tokens.length-1&&(s++,!(e.tokens[s].type===n.TokenTypes.Bracket&&(e.tokens[s].symbol==="("?f++:f--,f===0))););if(f!==0)throw new SyntaxError(`Unbalanced bracket at ${e.position()}.`);if(s===i+1)throw new SyntaxError(`Empty brackets at ${e.position()}.`);e.index=s;const o=r(e.tokens.slice(i+1,s));switch(o.content.precedence=l,e.pointer.type){case n.TreeTypes.Root:{const b=e.pointer;e.pointer=b.content=o.content;break}case n.TreeTypes.UnaryOp:{const b=e.pointer;e.pointer=b.argument=o.content;break}case n.TreeTypes.BinaryOp:{const b=e.pointer;e.pointer=b.right=o.content;break}}}function h(y,e){if(e.pointer.type===n.TreeTypes.Numeral)throw new SyntaxError(`Missing operator between numerals at ${e.position()}.`);const i=new a(e.pointer,y);switch(e.pointer.type){case n.TreeTypes.Root:{const s=e.pointer;e.pointer=s.content=i;break}case n.TreeTypes.UnaryOp:{const s=e.pointer;e.pointer=s.argument=i;break}case n.TreeTypes.BinaryOp:{const s=e.pointer;e.pointer=s.right=i;break}}}function m(y,e){for(;e.pointer.type!==n.TreeTypes.Root&&e.pointer.precedence>u;)e.pointer=e.pointer.parent;const s=p.getUnaryOpWithSymbol(y.symbol).type===n.UnaryOpTypes.Postfix;if(s&&!(e.pointer.type===n.TreeTypes.Root&&e.pointer.content||e.pointer.type===n.TreeTypes.UnaryOp&&e.pointer.argument||e.pointer.type===n.TreeTypes.BinaryOp&&e.pointer.right))throw new SyntaxError(`Missing entry before postfix unary operator at ${e.position()}.`);const f=new T(e.pointer,y);switch(e.pointer.type){case n.TreeTypes.Root:{const o=e.pointer;s&&(f.argument=o.content.clone()),e.pointer=o.content=f;break}case n.TreeTypes.UnaryOp:{const o=e.pointer;s&&(f.argument=o.argument.clone()),e.pointer=o.argument=f;break}case n.TreeTypes.BinaryOp:{const o=e.pointer;s&&(f.argument=o.right.clone()),e.pointer=o.right=f;break}}}function O(y,e){if(e.pointer.type===n.TreeTypes.Root)throw new SyntaxError(`Missing entry before binary operator at ${e.position()}.`);const i=p.getBinaryOpWithSymbol(y.symbol);for(;e.pointer.precedence>=i.precedence;)e.pointer=e.pointer.parent;const s=new w(e.pointer,y);switch(e.pointer.type){case n.TreeTypes.Root:{const f=e.pointer;s.left=f.content.clone(),e.pointer=f.content=s;break}case n.TreeTypes.UnaryOp:{const f=e.pointer;s.left=f.clone(),e.pointer=f.argument=s;break}case n.TreeTypes.BinaryOp:{const f=e.pointer;s.left=f.right.clone(),e.pointer=f.right=s;break}}}})($||($={}));var C;(t=>{function r(a){switch(a.type){case n.TreeTypes.Root:return c(a);case n.TreeTypes.Numeral:return g(a);case n.TreeTypes.UnaryOp:return l(a);case n.TreeTypes.BinaryOp:return u(a)}}t.evaluate=r;function c(a){if(!a.content)throw new SyntaxError("Evaluating empty tree.");return r(a.content)}function g(a){const T=a.numeral.symbol;return p.existConstantWithSymbol(T)?p.getConstantWithSymbol(T).value:Number(T)}function l(a){if(!a.argument)throw new SyntaxError(`Unary operator lacks argument at ${d(a.meta)}.`);const T=p.getUnaryOpWithSymbol(a.operator.symbol).callback;return T(r(a.argument))}function u(a){if(!a.left)throw new SyntaxError(`Binary operator lacks left operand at ${d(a.meta)}.`);if(!a.right)throw new SyntaxError(`Binary operator lacks right operand at ${d(a.meta)}.`);const T=p.getBinaryOpWithSymbol(a.operator.symbol).callback,w=r(a.left),E=r(a.right);return T(w,E)}const d=a=>`${a.from} - ${a.to}`})(C||(C={}));var N;(t=>{function r(g){const l=B.tokenize(g),u=$.parse(l),d=C.evaluate(u);return{tokens:l,tree:u,value:d}}t.calculate=r;function c(g){return r(g).value}t.value=c})(N||(N={}));const v=100,S=document.getElementById("input"),k=document.getElementById("result");M(S.getAttribute("placeholder"));S.oninput=()=>M(S.value);function M(t){console.clear(),k.classList.remove("error");let r;try{r=N.calculate(t.length===0?S.getAttribute("placeholder"):t)}catch(c){k.innerHTML="",k.classList.add("error");const g=document.createElement("p");g.textContent=`${c}`.replace(/.*Error: /,""),k.appendChild(g);return}console.log(`${r.tree}`),R(r.tokens,r.value)}function R(t,r){if(k.innerHTML="",t.length>v){const l=document.createElement("p");l.textContent="Expression",k.appendChild(l)}else for(const l of t){const u=document.createElement("p");u.textContent=l.symbol,u.className=n.TokenTypes[l.type],k.appendChild(u)}const c=document.createElement("p");c.textContent=" = ",k.appendChild(c);const g=document.createElement("p");g.textContent=`${r}`,k.appendChild(g)}
