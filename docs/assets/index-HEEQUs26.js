(function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))i(n);new MutationObserver(n=>{for(const a of n)if(a.type==="childList")for(const u of a.addedNodes)u.tagName==="LINK"&&u.rel==="modulepreload"&&i(u)}).observe(document,{childList:!0,subtree:!0});function e(n){const a={};return n.integrity&&(a.integrity=n.integrity),n.referrerPolicy&&(a.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?a.credentials="include":n.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function i(n){if(n.ep)return;n.ep=!0;const a=e(n);fetch(n.href,a)}})();const v=4;var c=(t=>(t[t.Bracket=0]="Bracket",t[t.UnaryOperator=1]="UnaryOperator",t[t.BinaryOperator=2]="BinaryOperator",t[t.Numeral=3]="Numeral",t))(c||{}),f=(t=>(t[t.Left=0]="Left",t[t.Right=1]="Right",t))(f||{}),p=(t=>(t[t.Pos=0]="Pos",t[t.Neg=1]="Neg",t))(p||{}),s=(t=>(t[t.Add=0]="Add",t[t.Sub=1]="Sub",t[t.Mul=2]="Mul",t[t.Div=3]="Div",t[t.Pow=4]="Pow",t))(s||{}),o=(t=>(t[t.Unset=0]="Unset",t[t.Numeral=1]="Numeral",t[t.Unary=2]="Unary",t[t.Binary=3]="Binary",t))(o||{});function N(t){const r=t.length,e=[];for(;t.length;){const i=r-t.length,n=U(t,e,i);if(!n)throw new SyntaxError(`Unknown symbol at index ${i}.`);t=t.slice(n.length)}return e}const B={[c.Bracket]:/[\(\)]/,[c.UnaryOperator]:/[\+\-]/,[c.BinaryOperator]:/[\+\-\*\/\^]/,[c.Numeral]:/\d+(?:\.\d+)?(?:[eE](?:[\+\-])?\d+)?/};function U(t,r,e){let i;for(let n=0;n<v;n++){const a=new RegExp(`^\\s*${B[n].source}\\s*`);if(i=t.match(a)?.[0],!i)continue;const u=i.trim();switch(n){case c.Bracket:{const l=u==="("?f.Left:f.Right,m=r.at(-1);(m?.type===c.Numeral||m?.type===c.Bracket&&m.value===f.Right)&&l===f.Left&&r.push({type:c.BinaryOperator,value:s.Mul,index:e}),r.push({type:c.Bracket,value:l,index:e});break}case c.UnaryOperator:{const l=r.at(-1);if(l?.type===void 0||l?.type===c.Bracket&&l.value===f.Left||l?.type===c.UnaryOperator||l?.type===c.BinaryOperator){r.push({type:c.UnaryOperator,value:u==="-"?p.Neg:p.Pos,index:e});break}}case c.BinaryOperator:{r.push({type:c.BinaryOperator,value:{"+":s.Add,"-":s.Sub,"*":s.Mul,"/":s.Div,"^":s.Pow}[u],index:e});break}case c.Numeral:{r.push({type:c.Numeral,value:Number(u),index:e});break}}break}return i}const k={[s.Add]:0,[s.Sub]:0,[s.Mul]:1,[s.Div]:1,[s.Pow]:2};function w(t){if(t.length===1){const n=t[0];if(n.type!==c.Numeral)throw new SyntaxError("Invalid single token.");return y(o.Numeral,{numeral:n})}const r={kind:o.Unset,content:{}};let e=r,i=0;for(;i<t.length;){const n=t[i];switch(n.type){case c.Bracket:{const a=E(t,i),u=w(t.slice(i+1,a));switch(i=a,e.kind){case o.Unset:{if(i===t.length-1){e.kind=u.kind,e.content=u.content;break}e.kind=o.Binary,e.content=y(o.Binary,{left:u}).content;break}case o.Unary:{e.content.argument=u;break}case o.Binary:{e.content.right=u;break}}break}case c.UnaryOperator:{const a=y(o.Unary,{operator:n});switch(e.kind){case o.Unset:{e.kind=o.Unary,e.content=a.content;break}case o.Unary:{e.content.argument=a,e=a;break}case o.Binary:{e.content.right=a,e=a;break}}break}case c.BinaryOperator:{if(e.kind===o.Unset)throw new SyntaxError("Binary operator at start of expression.");const a=n;if(e.kind===o.Binary&&!e.content.operator){e.content.operator=a;break}const u=e.kind===o.Unary||k[a.value]<=k[e.content.operator.value],l=y(o.Binary,{left:structuredClone(u?e:e.content.right),operator:a});if(u){e.kind=o.Binary,e.content=l.content;break}e.content.right=l,e=l;break}case c.Numeral:{const a=y(o.Numeral,{numeral:n});switch(e.kind){case o.Unset:{e.kind=o.Binary,e.content=y(o.Binary,{left:a}).content;break}case o.Unary:{e.content.argument=a;break}case o.Binary:{e.content.right=a;break}}break}}i++}return r}function E(t,r){let e=r,i=1;for(;e<t.length&&(e++,!(t[e].type===c.Bracket&&(t[e].value===f.Left?i++:i--,i===0))););if(i!==0)throw new SyntaxError(`No matching right bracket for left bracket at index ${r}`);if(e===r+1)throw new SyntaxError(`Empty brackets at index ${r}.`);return e}function y(t,r){return{kind:t,content:r}}function d(t){switch(t.kind){case o.Numeral:return t.content.numeral.value;case o.Unary:{const r=d(t.content.argument);return t.content.operator.value===p.Pos?r:-r}case o.Binary:{const r=d(t.content.left),e=d(t.content.right);switch(t.content.operator.value){case s.Add:return r+e;case s.Sub:return r-e;case s.Mul:return r*e;case s.Div:return r/e;case s.Pow:return r**e}}default:throw new SyntaxError(`AST not defined: ${JSON.stringify(t)}`)}}function b(t){return d(w(N(t)))}const h=document.getElementById("calc"),g=document.getElementById("res");g.textContent=String(b(h.getAttribute("placeholder")));h.oninput=()=>{if(h.value.length===0){g.textContent=String(b(h.getAttribute("placeholder")));return}try{g.textContent=String(b(h.value))}catch{g.textContent="Invalid Input"}};
