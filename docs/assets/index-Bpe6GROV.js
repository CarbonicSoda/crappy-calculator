(function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const y of document.querySelectorAll('link[rel="modulepreload"]'))g(y);new MutationObserver(y=>{for(const u of y)if(u.type==="childList")for(const d of u.addedNodes)d.tagName==="LINK"&&d.rel==="modulepreload"&&g(d)}).observe(document,{childList:!0,subtree:!0});function l(y){const u={};return y.integrity&&(u.integrity=y.integrity),y.referrerPolicy&&(u.referrerPolicy=y.referrerPolicy),y.crossOrigin==="use-credentials"?u.credentials="include":y.crossOrigin==="anonymous"?u.credentials="omit":u.credentials="same-origin",u}function g(y){if(y.ep)return;y.ep=!0;const u=l(y);fetch(y.href,u)}})();var n;(t=>{(r=>{r[r.Prefix=0]="Prefix",r[r.Postfix=1]="Postfix",r[r.Function=2]="Function"})(t.UnaryOpTypes||(t.UnaryOpTypes={})),(r=>{r[r.Bracket=0]="Bracket",r[r.Numeral=1]="Numeral",r[r.UnaryOp=2]="UnaryOp",r[r.BinaryOp=3]="BinaryOp"})(t.TokenTypes||(t.TokenTypes={})),(r=>{r[r.Root=0]="Root",r[r.Numeral=1]="Numeral",r[r.UnaryOp=2]="UnaryOp",r[r.BinaryOp=3]="BinaryOp"})(t.TreeTypes||(t.TreeTypes={}))})(n||(n={}));var a;(t=>{t.constantRegistry=new Map,t.constantSymbolRegistry=new Map,t.unaryOpRegistry=new Map,t.unaryOpSymbolRegistry=new Map,t.binaryOpRegistry=new Map,t.binaryOpSymbolRegistry=new Map;function r(o){return t.constantRegistry.has(o)}t.existConstant=r;function l(o){return t.constantSymbolRegistry.has(o)}t.existConstantWithSymbol=l;function g(o){return t.unaryOpRegistry.has(o)}t.existUnaryOp=g;function y(o){return t.unaryOpSymbolRegistry.has(o)}t.existUnaryOpWithSymbol=y;function u(o){return t.binaryOpRegistry.has(o)}t.existBinaryOp=u;function d(o){return t.binaryOpSymbolRegistry.has(o)}t.existBinaryOpWithSymbol=d;function s(o,O){if(r(o))throw new Error(`Constant with id ${o} already exists.`);if(l(O.symbol))throw new Error(`Constant with symbol ${O.symbol} already exists.`);t.constantRegistry.set(o,{id:o,...O}),t.constantSymbolRegistry.set(O.symbol,{id:o,...O})}t.registerConstant=s;function T(o,O){if(g(o))throw new Error(`Unary operator with id ${o} already exists.`);if(y(O.symbol))throw new Error(`Unary operator with symbol ${O.symbol} already exists.`);t.unaryOpRegistry.set(o,{id:o,...O}),t.unaryOpSymbolRegistry.set(O.symbol,{id:o,...O})}t.registerUnaryOp=T;function k(o,O){if(u(o))throw new Error(`Binary operator with id ${o} already exists.`);if(d(O.symbol))throw new Error(`Binary operator with symbol ${O.symbol} already exists.`);t.binaryOpRegistry.set(o,{id:o,...O}),t.binaryOpSymbolRegistry.set(O.symbol,{id:o,...O})}t.registerBinaryOp=k;function w(){return[...t.constantSymbolRegistry.keys()]}t.getConstantSymbols=w;function h(){return[...t.unaryOpSymbolRegistry.keys()]}t.getUnaryOpSymbols=h;function m(){return[...t.binaryOpSymbolRegistry.keys()]}t.getBinaryOpSymbols=m;function b(o){if(!r(o))throw new Error(`Constant with id ${o} is not registered.`);return t.constantRegistry.get(o)}t.getConstant=b;function c(o){if(!l(o))throw new Error(`Constant with symbol ${o} is not registered.`);return t.constantSymbolRegistry.get(o)}t.getConstantWithSymbol=c;function e(o){if(!g(o))throw new Error(`Unary operator with id ${o} is not registered.`);return t.unaryOpRegistry.get(o)}t.getUnaryOp=e;function p(o){if(!y(o))throw new Error(`Unary operator with symbol ${o} is not registered.`);return t.unaryOpSymbolRegistry.get(o)}t.getUnaryOpWithSymbol=p;function i(o){if(!u(o))throw new Error(`Binary operator with id ${o} is not registered.`);return t.binaryOpRegistry.get(o)}t.getBinaryOp=i;function f(o){if(!d(o))throw new Error(`Binary operator with symbol ${o} is not registered.`);return t.binaryOpSymbolRegistry.get(o)}t.getBinaryOpWithSymbol=f})(a||(a={}));var S;(t=>{function l(s){if(s===1/0)return 1/0;if(s>=0&&s<100&&Number.isInteger(s)){let T=1;for(let k=2;k<s+1;k++)T*=k;return T}return y(s+1)}t.factorial=l;function g(s){return l(s-1)}t.gamma=g;function y(s){const k=[.9999999999998099,676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,15056327351493116e-23];if(s<.5)return Math.PI/(Math.sin(Math.PI*s)*y(1-s));s--;let w=k[0];for(let b=1;b<9;b++)w+=k[b]/(s+b);const h=s+7+.5,m=Math.pow(h,s+.5);return m===1/0?1/0:Math.sqrt(2*Math.PI)*m*Math.exp(-h)*w}function u(s,T){return l(s)/l(s-T)}t.permutation=u;function d(s,T){return u(s,T)/l(T)}t.combination=d})(S||(S={}));a.registerConstant("e",{symbol:"E",value:Math.E});a.registerConstant("pi",{symbol:"PI",value:Math.PI});a.registerUnaryOp("pos",{symbol:"+",type:n.UnaryOpTypes.Prefix,callback:t=>t});a.registerUnaryOp("neg",{symbol:"-",type:n.UnaryOpTypes.Prefix,callback:t=>-t});a.registerUnaryOp("factorial",{symbol:"!",type:n.UnaryOpTypes.Postfix,callback:S.factorial});a.registerUnaryOp("degree",{symbol:"d",type:n.UnaryOpTypes.Postfix,callback:t=>Math.PI*t/180});a.registerUnaryOp("abs",{symbol:"abs",type:n.UnaryOpTypes.Function,callback:Math.abs});a.registerUnaryOp("floor",{symbol:"floor",type:n.UnaryOpTypes.Function,callback:Math.floor});a.registerUnaryOp("ceil",{symbol:"ceil",type:n.UnaryOpTypes.Function,callback:Math.ceil});a.registerUnaryOp("round",{symbol:"round",type:n.UnaryOpTypes.Function,callback:Math.round});a.registerUnaryOp("sqrt",{symbol:"sqrt",type:n.UnaryOpTypes.Function,callback:Math.sqrt});a.registerUnaryOp("exp",{symbol:"exp",type:n.UnaryOpTypes.Function,callback:Math.exp});a.registerUnaryOp("log",{symbol:"Ln",type:n.UnaryOpTypes.Function,callback:Math.log});a.registerUnaryOp("log10",{symbol:"log",type:n.UnaryOpTypes.Function,callback:Math.log10});a.registerUnaryOp("sin",{symbol:"sin",type:n.UnaryOpTypes.Function,callback:Math.sin});a.registerUnaryOp("cos",{symbol:"cos",type:n.UnaryOpTypes.Function,callback:Math.cos});a.registerUnaryOp("tan",{symbol:"tan",type:n.UnaryOpTypes.Function,callback:Math.tan});a.registerUnaryOp("asin",{symbol:"asin",type:n.UnaryOpTypes.Function,callback:Math.asin});a.registerUnaryOp("acos",{symbol:"acos",type:n.UnaryOpTypes.Function,callback:Math.acos});a.registerUnaryOp("atan",{symbol:"atan",type:n.UnaryOpTypes.Function,callback:Math.atan});a.registerUnaryOp("gamma",{symbol:"Gamma",type:n.UnaryOpTypes.Function,callback:S.gamma});a.registerBinaryOp("add",{symbol:"+",callback:(t,r)=>t+r,precedence:0});a.registerBinaryOp("sub",{symbol:"-",callback:(t,r)=>t-r,precedence:0});a.registerBinaryOp("mul",{symbol:"*",callback:(t,r)=>t*r,precedence:1});a.registerBinaryOp("div",{symbol:"/",callback:(t,r)=>t/r,precedence:1});a.registerBinaryOp("int_div",{symbol:"//",callback:(t,r)=>Math.floor(t/r),precedence:1});a.registerBinaryOp("pow",{symbol:"**",callback:(t,r)=>t**r,precedence:2});a.registerBinaryOp("pow_alias",{symbol:"^",callback:(t,r)=>t**r,precedence:2});a.registerBinaryOp("mod",{symbol:"%",callback:(t,r)=>t%r,precedence:2});const B=100;a.registerBinaryOp("min",{symbol:"min",callback:Math.min,precedence:B});a.registerBinaryOp("max",{symbol:"max",callback:Math.max,precedence:B});a.registerBinaryOp("permutation",{symbol:"P",callback:S.permutation,precedence:B});a.registerBinaryOp("combination",{symbol:"C",callback:S.combination,precedence:B});var $;(t=>{function r(h){const m=h.length,b=[];for(;h.length;){const c=m-h.length,e=d(h,c,b);h=h.slice(e.length)}return b}t.tokenize=r;class l{constructor(m,b,c){this.type=m,this.symbol=b,this.meta=c}toString(){return`[${this.meta.from===this.meta.to?this.meta.from:`${this.meta.from}-${this.meta.to}`}] ${this.symbol}`}toJSON(){return{symbol:this.symbol,meta:this.meta}}}t.Token=l;const g=h=>h.replaceAll(/[.*+?^${}()|[\]\\]/g,"\\$&"),y=Object.keys(n.TokenTypes).length/2,u={[n.TokenTypes.Bracket]:/[()]/,[n.TokenTypes.Numeral]:new RegExp(`(?:${a.getConstantSymbols().sort((h,m)=>m.length-h.length).map(g).join(")|(?:")})|(?:\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)`),[n.TokenTypes.UnaryOp]:new RegExp(`(?:${a.getUnaryOpSymbols().sort((h,m)=>m.length-h.length).map(g).join(")|(?:")})`),[n.TokenTypes.BinaryOp]:new RegExp(`(?:${a.getBinaryOpSymbols().sort((h,m)=>m.length-h.length).map(g).join(")|(?:")})`)};function d(h,m,b){let c;for(let e=0;e<y;e++){const p=new RegExp(`^\\s*(?:${u[e].source})\\s*`);if(c=h.match(p)?.[0],c===void 0)continue;let i=c.trimStart();const f=m+c.length-i.length;i=i.trimEnd();const o=f+i.length-1,O={from:f,to:o},x=b.at(-1);switch(e){case n.TokenTypes.Bracket:{if(s(b,i,O,x))break;continue}case n.TokenTypes.Numeral:{if(T(b,i,O,x))break;continue}case n.TokenTypes.UnaryOp:{if(k(b,i,O,x))break;continue}case n.TokenTypes.BinaryOp:{if(w(b,i,O))break;continue}}break}if(!c)throw new SyntaxError(`Invalid symbol at ${m}.`);return c}function s(h,m,b,c){const e=c?.symbol===")"||c?.type===n.TokenTypes.Numeral||c?.type===n.TokenTypes.UnaryOp&&a.getUnaryOpWithSymbol(c.symbol).type===n.UnaryOpTypes.Postfix;if(m==="("&&e&&a.existBinaryOp("mul")){const i=new l(n.TokenTypes.BinaryOp,a.getBinaryOp("mul").symbol,b);h.push(i)}const p=new l(n.TokenTypes.Bracket,m,b);return h.push(p)}function T(h,m,b,c){const e=c?.symbol===")"||c?.type===n.TokenTypes.Numeral||c?.type===n.TokenTypes.UnaryOp&&a.getUnaryOpWithSymbol(c.symbol).type===n.UnaryOpTypes.Postfix;if(a.existConstantWithSymbol(m)&&e&&a.existBinaryOp("mul")){const i=new l(n.TokenTypes.BinaryOp,a.getBinaryOp("mul").symbol,b);h.push(i)}const p=new l(n.TokenTypes.Numeral,m,b);return h.push(p)}function k(h,m,b,c){const e=c?.symbol===")"||c?.type===n.TokenTypes.Numeral||c?.type===n.TokenTypes.UnaryOp&&a.getUnaryOpWithSymbol(c.symbol).type===n.UnaryOpTypes.Postfix;switch(a.getUnaryOpWithSymbol(m).type){case n.UnaryOpTypes.Prefix:{if(e)return!1;break}case n.UnaryOpTypes.Postfix:{if(!e)return!1;break}case n.UnaryOpTypes.Function:{if(!e||!a.existBinaryOp("mul"))break;const i=new l(n.TokenTypes.BinaryOp,a.getBinaryOp("mul").symbol,b);h.push(i);break}}const p=new l(n.TokenTypes.UnaryOp,m,b);return h.push(p)}function w(h,m,b,c){const e=new l(n.TokenTypes.BinaryOp,m,b);return h.push(e)}})($||($={}));var N;(t=>{function r(c){const e=new d,p={index:0,position:()=>{const i=p.tokens[p.index];return`${i.meta.from} - ${i.meta.to}`},tokens:c,pointer:e};for(;p.index<c.length;){const i=c[p.index];switch(i.type){case n.TokenTypes.Bracket:{w(i,p);break}case n.TokenTypes.Numeral:{h(i,p);break}case n.TokenTypes.UnaryOp:{m(i,p);break}case n.TokenTypes.BinaryOp:{b(i,p);break}}p.index++}return e}t.parse=r;class l{constructor(e,p){this.type=e,this.precedence=p}clone(){const e=Object.create(Object.getPrototypeOf(this));return Object.defineProperties(e,Object.getOwnPropertyDescriptors(this)),e}}t.Tree=l;const g=-1,y=Number.MAX_SAFE_INTEGER+1,u=Number.MAX_SAFE_INTEGER;class d extends l{$content;set content(e){this.$content=e,e.parent=this}get content(){return this.$content}constructor(){super(n.TreeTypes.Root,g)}toString(){return this.content?this.content.toString():"<Empty>"}toJSON(){return this.content?.toJSON()??{}}}t.RootTree=d;class s extends l{constructor(e,p){super(n.TreeTypes.Numeral,y),this.parent=e,this.numToken=p}toString(e=1){return`<Num>${`
`+"  ┃  ".repeat(e)}${this.numToken}`}toJSON(){return{numeral:this.numToken.toJSON()}}}t.NumeralTree=s;class T extends l{constructor(e,p){super(n.TreeTypes.UnaryOp,u),this.parent=e,this.opToken=p,this.operator=a.getUnaryOpWithSymbol(p.symbol)}$argument;set argument(e){this.$argument=e,e.parent=this}get argument(){return this.$argument}operator;toString(e=1){const p=`
`+"  ┃  ".repeat(e);return`<Unary>${p}Op: ${this.opToken} (${this.operator.id})${p}Arg: ${this.argument?this.argument.toString(e+1):"<Empty>"}`}toJSON(){return{operator:{...this.opToken.toJSON(),...this.operator,type:n.UnaryOpTypes[this.operator.type]},argument:this.argument?.toJSON()??{}}}}t.UnaryOpTree=T;class k extends l{constructor(e,p){const i=a.getBinaryOpWithSymbol(p.symbol);super(n.TreeTypes.BinaryOp,i.precedence),this.parent=e,this.opToken=p,this.operator=i}$left;$right;set left(e){this.$left=e,e.parent=this}get left(){return this.$left}set right(e){this.$right=e,e.parent=this}get right(){return this.$right}operator;toString(e=1){const p=`
`+"  ┃  ".repeat(e);return`<Binary>${p}Op: ${this.opToken} (${this.operator.id})${p}Left: ${this.left?this.left.toString(e+1):"<Empty>"}${p}Right: ${this.right?this.right.toString(e+1):"<Empty>"}`}toJSON(){return{operator:{...this.opToken.toJSON(),...this.operator},left:this.left?.toJSON()??{},right:this.right?.toJSON()??{}}}}t.BinaryOpTree=k;function w(c,e){if(c.symbol===")")throw new SyntaxError(`Lone right bracket at ${e.position()}.`);if(e.pointer.type===n.TreeTypes.Numeral)throw new SyntaxError(`Missing operator before bracket at ${e.position()}.`);const p=e.index;let i=p,f=1;for(;i<e.tokens.length-1&&(i++,!(e.tokens[i].type===n.TokenTypes.Bracket&&(e.tokens[i].symbol==="("?f++:f--,f===0))););if(f!==0)throw new SyntaxError(`Unbalanced bracket at ${e.position()}.`);if(i===p+1)throw new SyntaxError(`Empty brackets at ${e.position()}.`);e.index=i;const o=r(e.tokens.slice(p+1,i));switch(o.content.precedence=y,e.pointer.type){case n.TreeTypes.Root:{const O=e.pointer;e.pointer=O.content=o.content;break}case n.TreeTypes.UnaryOp:{const O=e.pointer;e.pointer=O.argument=o.content;break}case n.TreeTypes.BinaryOp:{const O=e.pointer;e.pointer=O.right=o.content;break}}}function h(c,e){if(e.pointer.type===n.TreeTypes.Numeral)throw new SyntaxError(`Missing operator between numerals at ${e.position()}.`);const p=new s(e.pointer,c);switch(e.pointer.type){case n.TreeTypes.Root:{const i=e.pointer;e.pointer=i.content=p;break}case n.TreeTypes.UnaryOp:{const i=e.pointer;e.pointer=i.argument=p;break}case n.TreeTypes.BinaryOp:{const i=e.pointer;e.pointer=i.right=p;break}}}function m(c,e){for(;e.pointer.type!==n.TreeTypes.Root&&e.pointer.precedence>u;)e.pointer=e.pointer.parent;const i=a.getUnaryOpWithSymbol(c.symbol).type===n.UnaryOpTypes.Postfix;if(i&&!(e.pointer.type===n.TreeTypes.Root&&e.pointer.content||e.pointer.type===n.TreeTypes.UnaryOp&&e.pointer.argument||e.pointer.type===n.TreeTypes.BinaryOp&&e.pointer.right))throw new SyntaxError(`Missing entry before postfix unary operator at ${e.position()}.`);const f=new T(e.pointer,c);switch(e.pointer.type){case n.TreeTypes.Root:{const o=e.pointer;i&&(f.argument=o.content.clone()),e.pointer=o.content=f;break}case n.TreeTypes.UnaryOp:{const o=e.pointer;i&&(f.argument=o.argument.clone()),e.pointer=o.argument=f;break}case n.TreeTypes.BinaryOp:{const o=e.pointer;i&&(f.argument=o.right.clone()),e.pointer=o.right=f;break}}}function b(c,e){if(e.pointer.type===n.TreeTypes.Root)throw new SyntaxError(`Missing entry before binary operator at ${e.position()}.`);const p=a.getBinaryOpWithSymbol(c.symbol);for(;e.pointer.precedence>=p.precedence;)e.pointer=e.pointer.parent;const i=new k(e.pointer,c);switch(e.pointer.type){case n.TreeTypes.Root:{const f=e.pointer;i.left=f.content.clone(),e.pointer=f.content=i;break}case n.TreeTypes.UnaryOp:{const f=e.pointer;i.left=f.clone(),e.pointer=f.argument=i;break}case n.TreeTypes.BinaryOp:{const f=e.pointer;i.left=f.right.clone(),e.pointer=f.right=i;break}}}})(N||(N={}));var M;(t=>{function r(s){switch(s.type){case n.TreeTypes.Root:return l(s);case n.TreeTypes.Numeral:return g(s);case n.TreeTypes.UnaryOp:return y(s);case n.TreeTypes.BinaryOp:return u(s)}}t.evaluate=r;function l(s){if(!s.content)throw new SyntaxError("Evaluating empty tree.");return r(s.content)}function g(s){const T=s.numToken.symbol;return a.existConstantWithSymbol(T)?a.getConstantWithSymbol(T).value:Number(T)}function y(s){if(!s.argument)throw new SyntaxError(`Unary operator lacks argument at ${d(s.opToken.meta)}.`);const T=a.getUnaryOpWithSymbol(s.operator.symbol).callback;return T(r(s.argument))}function u(s){if(!s.left)throw new SyntaxError(`Binary operator lacks left operand at ${d(s.opToken.meta)}.`);if(!s.right)throw new SyntaxError(`Binary operator lacks right operand at ${d(s.opToken.meta)}.`);const T=a.getBinaryOpWithSymbol(s.operator.symbol).callback,k=r(s.left),w=r(s.right);return T(k,w)}const d=s=>`${s.from} - ${s.to}`})(M||(M={}));var C;(t=>{function r(g){const y=$.tokenize(g),u=N.parse(y),d=M.evaluate(u);return{tokens:y,tree:u,value:d}}t.calculate=r;function l(g){return r(g).value}t.value=l})(C||(C={}));const v=50,E=document.getElementById("input"),U=document.getElementById("result");P(E.getAttribute("placeholder"));E.oninput=()=>P(E.value);function P(t){console.clear(),U.classList.remove("error");let r,l;try{const g=performance.now();r=C.calculate(t.length===0?E.getAttribute("placeholder"):t),l=performance.now()-g}catch(g){U.innerHTML="",U.classList.add("error");const y=document.createElement("p");y.textContent=`${g}`.replace(/.*Error: /,""),U.appendChild(y);return}console.log(`Calculated in ${l}ms.`),console.log("<AST>",r.tree.toJSON()),console.log(`${r.tree}`),R(r.tokens,r.value)}function R(t,r){if(U.innerHTML="",t.reduce((y,u)=>y+u.symbol.length,0)>v){const y=document.createElement("p");y.textContent="Expression",U.appendChild(y)}else for(const y of t){const u=document.createElement("p");u.textContent=y.symbol,u.className=n.TokenTypes[y.type],U.appendChild(u)}const l=document.createElement("p");l.textContent=" = ",U.appendChild(l);const g=document.createElement("p");g.textContent=`${r}`,U.appendChild(g)}
